<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PennOS: src/util/pennfat_kernel.h File Reference</title>
<link rel="icon" href="../../icons8-document-50.png" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">PennOS<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">PennOS, a UNIX-like operating system.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="../../dir_b7878ad5ecbf2506f4125b9d34c97e45.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pennfat_kernel.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;<a class="el" href="../../dc/d3d/pennfat_8h_source.html">../pennfat.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../dc/d15/spthread_8h_source.html">spthread.h</a>&quot;</code><br />
</div>
<p><a href="../../d0/d4d/pennfat__kernel_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d68/structdirectory__entries.html">directory_entries</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure stores all required information about the directory entries that are stored in the root directory.  <a href="../../d8/d68/structdirectory__entries.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d06/structfile__descriptor__st.html">file_descriptor_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure stores all required information about the file descriptor.  <a href="../../d1/d06/structfile__descriptor__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab86e09c9385938942f76becf2c2aae95" id="r_ab86e09c9385938942f76becf2c2aae95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab86e09c9385938942f76becf2c2aae95">F_READ</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ab86e09c9385938942f76becf2c2aae95"><td class="mdescLeft">&#160;</td><td class="mdescRight">open the file for reading only  <br /></td></tr>
<tr class="separator:ab86e09c9385938942f76becf2c2aae95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bc715eea79704953e87d562e15f366" id="r_a65bc715eea79704953e87d562e15f366"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65bc715eea79704953e87d562e15f366">F_WRITE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a65bc715eea79704953e87d562e15f366"><td class="mdescLeft">&#160;</td><td class="mdescRight">writing and reading, truncates if the file exists, or creates it if it does not exist. Only one instance of a file can be opened in F_WRITE mode; error if attempted to open a file in F_WRITE mode more than once  <br /></td></tr>
<tr class="separator:a65bc715eea79704953e87d562e15f366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298b91deec2bed5a79398eedd81cd754" id="r_a298b91deec2bed5a79398eedd81cd754"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a298b91deec2bed5a79398eedd81cd754">F_APPEND</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a298b91deec2bed5a79398eedd81cd754"><td class="mdescLeft">&#160;</td><td class="mdescRight">open the file for reading and writing but does not truncate the file if exists; additionally, the file pointer references the end of the file.  <br /></td></tr>
<tr class="separator:a298b91deec2bed5a79398eedd81cd754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42dd65bff5e0d98e3d17b523e65b9e06" id="r_a42dd65bff5e0d98e3d17b523e65b9e06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42dd65bff5e0d98e3d17b523e65b9e06">MAX_FD_NUM</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:a42dd65bff5e0d98e3d17b523e65b9e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the global_fd_table.  <br /></td></tr>
<tr class="separator:a42dd65bff5e0d98e3d17b523e65b9e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775241e32b7ccb12e344ae23aa2db6b1" id="r_a775241e32b7ccb12e344ae23aa2db6b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a775241e32b7ccb12e344ae23aa2db6b1">FILE_NOT_FOUND</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:a775241e32b7ccb12e344ae23aa2db6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error number for when there does not exist a file with the given file name.  <br /></td></tr>
<tr class="separator:a775241e32b7ccb12e344ae23aa2db6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766ef9868dc2ca892fec7594bf5c001f" id="r_a766ef9868dc2ca892fec7594bf5c001f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a766ef9868dc2ca892fec7594bf5c001f">INVALID_FILE_NAME</a>&#160;&#160;&#160;-2</td></tr>
<tr class="memdesc:a766ef9868dc2ca892fec7594bf5c001f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error number for when the file name doesn't follow the POSIX standard.  <br /></td></tr>
<tr class="separator:a766ef9868dc2ca892fec7594bf5c001f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d87b58f2f59988fb038e8e7a624d3a1" id="r_a6d87b58f2f59988fb038e8e7a624d3a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d87b58f2f59988fb038e8e7a624d3a1">MULTIPLE_F_WRITE</a>&#160;&#160;&#160;-3</td></tr>
<tr class="memdesc:a6d87b58f2f59988fb038e8e7a624d3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error number for when trying to open more than one file descriptor in F_WRITE / F_APPEND mode.  <br /></td></tr>
<tr class="separator:a6d87b58f2f59988fb038e8e7a624d3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f508739f76b70b145cc951856b9bb10" id="r_a4f508739f76b70b145cc951856b9bb10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f508739f76b70b145cc951856b9bb10">WRONG_PERMISSION</a>&#160;&#160;&#160;-4</td></tr>
<tr class="memdesc:a4f508739f76b70b145cc951856b9bb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error number for when trying to use the file descriptor in an invalid way such as writing to F_READ file descriptor.  <br /></td></tr>
<tr class="separator:a4f508739f76b70b145cc951856b9bb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc193a671d528c44d636e641c0eedf1e" id="r_afc193a671d528c44d636e641c0eedf1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc193a671d528c44d636e641c0eedf1e">SYSTEM_ERROR</a>&#160;&#160;&#160;-5</td></tr>
<tr class="memdesc:afc193a671d528c44d636e641c0eedf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error number for when C level system function fails.  <br /></td></tr>
<tr class="separator:afc193a671d528c44d636e641c0eedf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94473fc029d7adc723de1a71f26c7e8b" id="r_a94473fc029d7adc723de1a71f26c7e8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94473fc029d7adc723de1a71f26c7e8b">FILE_DELETED</a>&#160;&#160;&#160;-6</td></tr>
<tr class="memdesc:a94473fc029d7adc723de1a71f26c7e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error number for when trying to access or use a deleted file.  <br /></td></tr>
<tr class="separator:a94473fc029d7adc723de1a71f26c7e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac464698b9650d3fae2d2fa746624130a" id="r_ac464698b9650d3fae2d2fa746624130a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac464698b9650d3fae2d2fa746624130a">INVALID_FILE_DESCRIPTOR</a>&#160;&#160;&#160;-7</td></tr>
<tr class="memdesc:ac464698b9650d3fae2d2fa746624130a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error number for when trying to access or use a invalid file descriptor.  <br /></td></tr>
<tr class="separator:ac464698b9650d3fae2d2fa746624130a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2ba7f8612dbda8692281d69b237221" id="r_a2c2ba7f8612dbda8692281d69b237221"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c2ba7f8612dbda8692281d69b237221">FILE_IN_USE</a>&#160;&#160;&#160;-8</td></tr>
<tr class="memdesc:a2c2ba7f8612dbda8692281d69b237221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error number for when delete a file that is used by some other processes.  <br /></td></tr>
<tr class="separator:a2c2ba7f8612dbda8692281d69b237221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388389bcfc8bc6948baafab7862e0ad9" id="r_a388389bcfc8bc6948baafab7862e0ad9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a388389bcfc8bc6948baafab7862e0ad9">INVALID_PARAMETERS</a>&#160;&#160;&#160;-9</td></tr>
<tr class="memdesc:a388389bcfc8bc6948baafab7862e0ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error number for when the parameter given to the function is invalid.  <br /></td></tr>
<tr class="separator:a388389bcfc8bc6948baafab7862e0ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5570301c863e2a1c4cdcc49083d8a041" id="r_a5570301c863e2a1c4cdcc49083d8a041"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5570301c863e2a1c4cdcc49083d8a041">FS_NOT_MOUNTED</a>&#160;&#160;&#160;-10</td></tr>
<tr class="memdesc:a5570301c863e2a1c4cdcc49083d8a041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error number for when the filesystem is not mounted but tries to access or use the file system.  <br /></td></tr>
<tr class="separator:a5570301c863e2a1c4cdcc49083d8a041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a157e51c85caee5bec44a2f9a4e5605e6" id="r_a157e51c85caee5bec44a2f9a4e5605e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a157e51c85caee5bec44a2f9a4e5605e6">Whence</a> { <a class="el" href="#a157e51c85caee5bec44a2f9a4e5605e6ad21e659a9215dc7d9bc52f5d7e27b7cb">F_SEEK_SET</a>
, <a class="el" href="#a157e51c85caee5bec44a2f9a4e5605e6ab31ac29c12e35bd468f95e18263e9850">F_SEEK_CUR</a>
, <a class="el" href="#a157e51c85caee5bec44a2f9a4e5605e6a3efde7f3f3639fd0801644753d2e5674">F_SEEK_END</a>
 }</td></tr>
<tr class="memdesc:a157e51c85caee5bec44a2f9a4e5605e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how the offset will be calculated when using the k_lseek method. For more detail, refer to lseek(2).  <a href="#a157e51c85caee5bec44a2f9a4e5605e6">More...</a><br /></td></tr>
<tr class="separator:a157e51c85caee5bec44a2f9a4e5605e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a25ad4d01d5ade905b2bfce04910a5c0d" id="r_a25ad4d01d5ade905b2bfce04910a5c0d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="../../d1/d06/structfile__descriptor__st.html">file_descriptor_st</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25ad4d01d5ade905b2bfce04910a5c0d">create_file_descriptor</a> (int fd, char *fname, int mode, int offset)</td></tr>
<tr class="memdesc:a25ad4d01d5ade905b2bfce04910a5c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="../../d1/d06/structfile__descriptor__st.html" title="This structure stores all required information about the file descriptor.">file_descriptor_st</a> struct, initialized with the values provided by the parameters. For more information of the parameters, refer to struct <a class="el" href="../../d1/d06/structfile__descriptor__st.html" title="This structure stores all required information about the file descriptor.">file_descriptor_st</a>.  <br /></td></tr>
<tr class="separator:a25ad4d01d5ade905b2bfce04910a5c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd2d5dba8f5f42be13d549b0e08a3ad" id="r_a3fd2d5dba8f5f42be13d549b0e08a3ad"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="../../d8/d68/structdirectory__entries.html">directory_entries</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fd2d5dba8f5f42be13d549b0e08a3ad">create_directory_entry</a> (const char *name, uint32_t size, uint16_t firstBlock, uint8_t type, uint8_t perm, time_t mtime)</td></tr>
<tr class="memdesc:a3fd2d5dba8f5f42be13d549b0e08a3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="../../d8/d68/structdirectory__entries.html" title="This structure stores all required information about the directory entries that are stored in the roo...">directory_entries</a> struct, initialized with the values provided by the parameters. For more information of the parameters, refer to struct <a class="el" href="../../d8/d68/structdirectory__entries.html" title="This structure stores all required information about the directory entries that are stored in the roo...">directory_entries</a>.  <br /></td></tr>
<tr class="separator:a3fd2d5dba8f5f42be13d549b0e08a3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d501c304eeba5035c83c1e2a4aec4fb" id="r_a2d501c304eeba5035c83c1e2a4aec4fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d501c304eeba5035c83c1e2a4aec4fb">lseek_to_root_directory</a> ()</td></tr>
<tr class="memdesc:a2d501c304eeba5035c83c1e2a4aec4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">lseek the file system's offset to the start of the root directory.  <br /></td></tr>
<tr class="separator:a2d501c304eeba5035c83c1e2a4aec4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580177591867f52c90932219a6c29e71" id="r_a580177591867f52c90932219a6c29e71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a580177591867f52c90932219a6c29e71">extend_fat</a> (int start_index, int empty_fat_index)</td></tr>
<tr class="memdesc:a580177591867f52c90932219a6c29e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the fat region of the given file (marked by the <code>start_index</code> ) by one block.  <br /></td></tr>
<tr class="separator:a580177591867f52c90932219a6c29e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbc36d23ce41b02cb1508bf85ca24e2" id="r_addbc36d23ce41b02cb1508bf85ca24e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addbc36d23ce41b02cb1508bf85ca24e2">get_first_empty_fat_index</a> ()</td></tr>
<tr class="memdesc:addbc36d23ce41b02cb1508bf85ca24e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the first empty fat index marked as 0x0000.  <br /></td></tr>
<tr class="separator:addbc36d23ce41b02cb1508bf85ca24e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6532ad36b852dd09d641bcaac2642b9b" id="r_a6532ad36b852dd09d641bcaac2642b9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6532ad36b852dd09d641bcaac2642b9b">move_to_open_de</a> (bool found)</td></tr>
<tr class="memdesc:a6532ad36b852dd09d641bcaac2642b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the offset to the fs_fd to the first open directory entry.  <br /></td></tr>
<tr class="separator:a6532ad36b852dd09d641bcaac2642b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d95341bbd2b21ed69dd341ff47669f" id="r_a78d95341bbd2b21ed69dd341ff47669f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="../../d8/d68/structdirectory__entries.html">directory_entries</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78d95341bbd2b21ed69dd341ff47669f">does_file_exist</a> (const char *fname)</td></tr>
<tr class="memdesc:a78d95341bbd2b21ed69dd341ff47669f"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper that traverses root directory block by block to check if fname file exists return: the directory entry struct with name fname (NULL if not found) also moves fs_fd to the end of the root directory  <br /></td></tr>
<tr class="separator:a78d95341bbd2b21ed69dd341ff47669f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8434cdce67b1512300f44ed38497c22a" id="r_a8434cdce67b1512300f44ed38497c22a"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8434cdce67b1512300f44ed38497c22a">does_file_exist2</a> (const char *fname)</td></tr>
<tr class="memdesc:a8434cdce67b1512300f44ed38497c22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that given a files name, it outputs the offset to the directory entry or negative number if the file isn't found.  <br /></td></tr>
<tr class="separator:a8434cdce67b1512300f44ed38497c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f9a41e9fb0fdf97403eff276990e1f" id="r_af7f9a41e9fb0fdf97403eff276990e1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7f9a41e9fb0fdf97403eff276990e1f">k_count_fd_num</a> (const char *name)</td></tr>
<tr class="memdesc:af7f9a41e9fb0fdf97403eff276990e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of currently open in the global_fd_table with the <code>name</code> as the fname.  <br /></td></tr>
<tr class="separator:af7f9a41e9fb0fdf97403eff276990e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5ffc180d9fc063efc7127d14378b54" id="r_abe5ffc180d9fc063efc7127d14378b54"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="../../d1/d06/structfile__descriptor__st.html">file_descriptor_st</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe5ffc180d9fc063efc7127d14378b54">get_file_descriptor</a> (int fd)</td></tr>
<tr class="memdesc:abe5ffc180d9fc063efc7127d14378b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the file descriptor struct for the given file descriptor number.  <br /></td></tr>
<tr class="separator:abe5ffc180d9fc063efc7127d14378b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2cf4232cddee738996ca9ad83ea56f" id="r_a4d2cf4232cddee738996ca9ad83ea56f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d2cf4232cddee738996ca9ad83ea56f">k_open</a> (const char *fname, int mode)</td></tr>
<tr class="memdesc:a4d2cf4232cddee738996ca9ad83ea56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open file name <code>fname</code> with the mode <code>mode</code>, and return a file descriptor to that file.  <br /></td></tr>
<tr class="separator:a4d2cf4232cddee738996ca9ad83ea56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1951ec11865274b45144d6dd6f878692" id="r_a1951ec11865274b45144d6dd6f878692"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1951ec11865274b45144d6dd6f878692">k_read</a> (int fd, int n, char *buf)</td></tr>
<tr class="memdesc:a1951ec11865274b45144d6dd6f878692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read n bytes from the file referenced by fd. On return, k_read returns the number of bytes read, 0 if EOF is reached, or a negative number on error.  <br /></td></tr>
<tr class="separator:a1951ec11865274b45144d6dd6f878692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d2a9b65d0e04de358fe1a2cfa79baf" id="r_a79d2a9b65d0e04de358fe1a2cfa79baf"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79d2a9b65d0e04de358fe1a2cfa79baf">k_write</a> (int fd, const char *str, int n)</td></tr>
<tr class="memdesc:a79d2a9b65d0e04de358fe1a2cfa79baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write n bytes of the string referenced by str to the file fd and increment the file pointer by n. On return, k_write returns the number of bytes written, or a negative value on error.  <br /></td></tr>
<tr class="separator:a79d2a9b65d0e04de358fe1a2cfa79baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecd38dc6f3a9721ab53ff9a815b5480" id="r_a9ecd38dc6f3a9721ab53ff9a815b5480"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ecd38dc6f3a9721ab53ff9a815b5480">k_close</a> (int fd)</td></tr>
<tr class="memdesc:a9ecd38dc6f3a9721ab53ff9a815b5480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the file fd and return 0 on success, or a negative value on failure.  <br /></td></tr>
<tr class="separator:a9ecd38dc6f3a9721ab53ff9a815b5480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b44b3621ebb542bec49f73d19d2885" id="r_ae8b44b3621ebb542bec49f73d19d2885"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8b44b3621ebb542bec49f73d19d2885">k_unlink</a> (const char *fname)</td></tr>
<tr class="memdesc:ae8b44b3621ebb542bec49f73d19d2885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the file by freeing the FAT table and zeroing out previously existing data.  <br /></td></tr>
<tr class="separator:ae8b44b3621ebb542bec49f73d19d2885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332b4729ef52b2a3132b1aea88fa5c96" id="r_a332b4729ef52b2a3132b1aea88fa5c96"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a332b4729ef52b2a3132b1aea88fa5c96">k_lseek</a> (int fd, int offset, int whence)</td></tr>
<tr class="memdesc:a332b4729ef52b2a3132b1aea88fa5c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reposition the file pointer for fd to the offset relative to whence. Refer to lseek(2) for how whence interacts with the file offset. If the newly calculated offset is creater than the current size of the file, the file expands to match that offset with the newly allocated space filled with 0s.  <br /></td></tr>
<tr class="separator:a332b4729ef52b2a3132b1aea88fa5c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a03cfc7e106d29d54196f03557b9ba" id="r_aa1a03cfc7e106d29d54196f03557b9ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1a03cfc7e106d29d54196f03557b9ba">k_ls</a> (const char *filename, int fd)</td></tr>
<tr class="memdesc:aa1a03cfc7e106d29d54196f03557b9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the file filename in the current directory. If filename is NULL, list all files in the current directory.  <br /></td></tr>
<tr class="separator:aa1a03cfc7e106d29d54196f03557b9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85eace193c41193d1646af1a8b943200" id="r_a85eace193c41193d1646af1a8b943200"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85eace193c41193d1646af1a8b943200">k_rename</a> (const char *source, const char *dest)</td></tr>
<tr class="memdesc:a85eace193c41193d1646af1a8b943200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename <code>source</code> to <code>dest</code>.  <br /></td></tr>
<tr class="separator:a85eace193c41193d1646af1a8b943200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf487212da5b9d6ebceef678fa744ad9" id="r_abf487212da5b9d6ebceef678fa744ad9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf487212da5b9d6ebceef678fa744ad9">k_update_timestamp</a> (const char *source)</td></tr>
<tr class="memdesc:abf487212da5b9d6ebceef678fa744ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the timestamp of the file to the current time.  <br /></td></tr>
<tr class="separator:abf487212da5b9d6ebceef678fa744ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e9851dc3cbc61a9f8ffd36b94b9938" id="r_ad4e9851dc3cbc61a9f8ffd36b94b9938"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4e9851dc3cbc61a9f8ffd36b94b9938">k_change_mode</a> (const char *change, const char *filename)</td></tr>
<tr class="memdesc:ad4e9851dc3cbc61a9f8ffd36b94b9938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change file mode bits.  <br /></td></tr>
<tr class="separator:ad4e9851dc3cbc61a9f8ffd36b94b9938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08194e0542962e4d980cd9278f33c7f5" id="r_a08194e0542962e4d980cd9278f33c7f5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08194e0542962e4d980cd9278f33c7f5">k_read_all</a> (const char *filename, int *read_num)</td></tr>
<tr class="memdesc:a08194e0542962e4d980cd9278f33c7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all contents from the file with the file name <code>filename</code>. Outputs the contents as well as update <code>read_num</code> to the number of bytes read.  <br /></td></tr>
<tr class="separator:a08194e0542962e4d980cd9278f33c7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada30dc78055b7b113ff2dac9aabe4eb3" id="r_ada30dc78055b7b113ff2dac9aabe4eb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada30dc78055b7b113ff2dac9aabe4eb3">is_file_name_valid</a> (char *name)</td></tr>
<tr class="memdesc:ada30dc78055b7b113ff2dac9aabe4eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the filename follows the POSIX standard.  <br /></td></tr>
<tr class="separator:ada30dc78055b7b113ff2dac9aabe4eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d6a9bc81e4cf0788c8f1de39999c22" id="r_af6d6a9bc81e4cf0788c8f1de39999c22"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6d6a9bc81e4cf0788c8f1de39999c22">k_get_fname_from_fd</a> (int fd)</td></tr>
<tr class="memdesc:af6d6a9bc81e4cf0788c8f1de39999c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the filename for the given file descriptor number.  <br /></td></tr>
<tr class="separator:af6d6a9bc81e4cf0788c8f1de39999c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82daa98d4c392b4249bfbc975be22daa" id="r_a82daa98d4c392b4249bfbc975be22daa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82daa98d4c392b4249bfbc975be22daa">k_cp_within_fat</a> (char *source, char *dest)</td></tr>
<tr class="memdesc:a82daa98d4c392b4249bfbc975be22daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents from <code>source</code> to <code>dest</code>. Both <code>source</code> and <code>dest</code> must be files within the PENNFAT system.  <br /></td></tr>
<tr class="separator:a82daa98d4c392b4249bfbc975be22daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad024bf5305fa73db8c92084f8a1df0" id="r_aaad024bf5305fa73db8c92084f8a1df0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad024bf5305fa73db8c92084f8a1df0">k_cp_to_host</a> (char *source, char *host_dest)</td></tr>
<tr class="memdesc:aaad024bf5305fa73db8c92084f8a1df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents from <code>source</code> to <code>host_dest</code> <code>source</code> must be a file within the PENNFAT system. <code>host_dest</code> is a host system file.  <br /></td></tr>
<tr class="separator:aaad024bf5305fa73db8c92084f8a1df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90de0cbbfd37f924016dd07d60d38853" id="r_a90de0cbbfd37f924016dd07d60d38853"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90de0cbbfd37f924016dd07d60d38853">k_cp_from_host</a> (char *host_source, char *dest)</td></tr>
<tr class="memdesc:a90de0cbbfd37f924016dd07d60d38853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents from <code>host_source</code> to <code>dest</code>. <code>dest</code> must be a file within the PENNFAT system. <code>host_source</code> is a host system file.  <br /></td></tr>
<tr class="separator:a90de0cbbfd37f924016dd07d60d38853"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0e52a1a113ded7f4787290edc22ad954" id="r_a0e52a1a113ded7f4787290edc22ad954"><td class="memItemLeft" align="right" valign="top">uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e52a1a113ded7f4787290edc22ad954">fat</a></td></tr>
<tr class="memdesc:a0e52a1a113ded7f4787290edc22ad954"><td class="mdescLeft">&#160;</td><td class="mdescRight">PennFAT filesystem that has been mounted to memory using the mmap(2).  <br /></td></tr>
<tr class="separator:a0e52a1a113ded7f4787290edc22ad954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07afa4cbf62f3ce8292a6ddbcb37c8fc" id="r_a07afa4cbf62f3ce8292a6ddbcb37c8fc"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="../../d1/d06/structfile__descriptor__st.html">file_descriptor_st</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07afa4cbf62f3ce8292a6ddbcb37c8fc">global_fd_table</a></td></tr>
<tr class="memdesc:a07afa4cbf62f3ce8292a6ddbcb37c8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel level global file descriptor table that stores all file descriptor that has been created through out the program's runtime.  <br /></td></tr>
<tr class="separator:a07afa4cbf62f3ce8292a6ddbcb37c8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b57b29bcc87a7b1967c7d55e7d4212" id="r_a64b57b29bcc87a7b1967c7d55e7d4212"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64b57b29bcc87a7b1967c7d55e7d4212">fs_fd</a></td></tr>
<tr class="memdesc:a64b57b29bcc87a7b1967c7d55e7d4212"><td class="mdescLeft">&#160;</td><td class="mdescRight">File descriptor number (host system level) for the filesystem that has been mounted to the program.  <br /></td></tr>
<tr class="separator:a64b57b29bcc87a7b1967c7d55e7d4212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b27761c7d0bd5cd90f4fe47e569b94" id="r_a70b27761c7d0bd5cd90f4fe47e569b94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70b27761c7d0bd5cd90f4fe47e569b94">block_size</a></td></tr>
<tr class="memdesc:a70b27761c7d0bd5cd90f4fe47e569b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block size of the currently mounted filesystem that is defined during the mkfs process.  <br /></td></tr>
<tr class="separator:a70b27761c7d0bd5cd90f4fe47e569b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5f2839b4852a1e8b5c0b10ec6caa5b" id="r_a6a5f2839b4852a1e8b5c0b10ec6caa5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a5f2839b4852a1e8b5c0b10ec6caa5b">fat_size</a></td></tr>
<tr class="memdesc:a6a5f2839b4852a1e8b5c0b10ec6caa5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">FAT region size of the currently mounted filesystem.  <br /></td></tr>
<tr class="separator:a6a5f2839b4852a1e8b5c0b10ec6caa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af866bcf6c2272c2f6b1b7e5ad3a2e127" id="r_af866bcf6c2272c2f6b1b7e5ad3a2e127"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af866bcf6c2272c2f6b1b7e5ad3a2e127">num_fat_entries</a></td></tr>
<tr class="memdesc:af866bcf6c2272c2f6b1b7e5ad3a2e127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated value of the total number of FAT entries within the currently mounted filesystem.  <br /></td></tr>
<tr class="separator:af866bcf6c2272c2f6b1b7e5ad3a2e127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69e180c878a9c8f4e45ec7dc25a062f" id="r_af69e180c878a9c8f4e45ec7dc25a062f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69e180c878a9c8f4e45ec7dc25a062f">data_size</a></td></tr>
<tr class="memdesc:af69e180c878a9c8f4e45ec7dc25a062f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated data region size of the currently mounted filesystem.  <br /></td></tr>
<tr class="separator:af69e180c878a9c8f4e45ec7dc25a062f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a298b91deec2bed5a79398eedd81cd754" name="a298b91deec2bed5a79398eedd81cd754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298b91deec2bed5a79398eedd81cd754">&#9670;&#160;</a></span>F_APPEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define F_APPEND&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>open the file for reading and writing but does not truncate the file if exists; additionally, the file pointer references the end of the file. </p>

</div>
</div>
<a id="ab86e09c9385938942f76becf2c2aae95" name="ab86e09c9385938942f76becf2c2aae95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86e09c9385938942f76becf2c2aae95">&#9670;&#160;</a></span>F_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define F_READ&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>open the file for reading only </p>

</div>
</div>
<a id="a65bc715eea79704953e87d562e15f366" name="a65bc715eea79704953e87d562e15f366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bc715eea79704953e87d562e15f366">&#9670;&#160;</a></span>F_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define F_WRITE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writing and reading, truncates if the file exists, or creates it if it does not exist. Only one instance of a file can be opened in F_WRITE mode; error if attempted to open a file in F_WRITE mode more than once </p>

</div>
</div>
<a id="a94473fc029d7adc723de1a71f26c7e8b" name="a94473fc029d7adc723de1a71f26c7e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94473fc029d7adc723de1a71f26c7e8b">&#9670;&#160;</a></span>FILE_DELETED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FILE_DELETED&#160;&#160;&#160;-6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error number for when trying to access or use a deleted file. </p>

</div>
</div>
<a id="a2c2ba7f8612dbda8692281d69b237221" name="a2c2ba7f8612dbda8692281d69b237221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2ba7f8612dbda8692281d69b237221">&#9670;&#160;</a></span>FILE_IN_USE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FILE_IN_USE&#160;&#160;&#160;-8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error number for when delete a file that is used by some other processes. </p>

</div>
</div>
<a id="a775241e32b7ccb12e344ae23aa2db6b1" name="a775241e32b7ccb12e344ae23aa2db6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775241e32b7ccb12e344ae23aa2db6b1">&#9670;&#160;</a></span>FILE_NOT_FOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FILE_NOT_FOUND&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error number for when there does not exist a file with the given file name. </p>

</div>
</div>
<a id="a5570301c863e2a1c4cdcc49083d8a041" name="a5570301c863e2a1c4cdcc49083d8a041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5570301c863e2a1c4cdcc49083d8a041">&#9670;&#160;</a></span>FS_NOT_MOUNTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FS_NOT_MOUNTED&#160;&#160;&#160;-10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error number for when the filesystem is not mounted but tries to access or use the file system. </p>

</div>
</div>
<a id="ac464698b9650d3fae2d2fa746624130a" name="ac464698b9650d3fae2d2fa746624130a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac464698b9650d3fae2d2fa746624130a">&#9670;&#160;</a></span>INVALID_FILE_DESCRIPTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVALID_FILE_DESCRIPTOR&#160;&#160;&#160;-7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error number for when trying to access or use a invalid file descriptor. </p>

</div>
</div>
<a id="a766ef9868dc2ca892fec7594bf5c001f" name="a766ef9868dc2ca892fec7594bf5c001f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766ef9868dc2ca892fec7594bf5c001f">&#9670;&#160;</a></span>INVALID_FILE_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVALID_FILE_NAME&#160;&#160;&#160;-2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error number for when the file name doesn't follow the POSIX standard. </p>

</div>
</div>
<a id="a388389bcfc8bc6948baafab7862e0ad9" name="a388389bcfc8bc6948baafab7862e0ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388389bcfc8bc6948baafab7862e0ad9">&#9670;&#160;</a></span>INVALID_PARAMETERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVALID_PARAMETERS&#160;&#160;&#160;-9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error number for when the parameter given to the function is invalid. </p>

</div>
</div>
<a id="a42dd65bff5e0d98e3d17b523e65b9e06" name="a42dd65bff5e0d98e3d17b523e65b9e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42dd65bff5e0d98e3d17b523e65b9e06">&#9670;&#160;</a></span>MAX_FD_NUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_FD_NUM&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the global_fd_table. </p>

</div>
</div>
<a id="a6d87b58f2f59988fb038e8e7a624d3a1" name="a6d87b58f2f59988fb038e8e7a624d3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d87b58f2f59988fb038e8e7a624d3a1">&#9670;&#160;</a></span>MULTIPLE_F_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MULTIPLE_F_WRITE&#160;&#160;&#160;-3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error number for when trying to open more than one file descriptor in F_WRITE / F_APPEND mode. </p>

</div>
</div>
<a id="afc193a671d528c44d636e641c0eedf1e" name="afc193a671d528c44d636e641c0eedf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc193a671d528c44d636e641c0eedf1e">&#9670;&#160;</a></span>SYSTEM_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSTEM_ERROR&#160;&#160;&#160;-5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error number for when C level system function fails. </p>

</div>
</div>
<a id="a4f508739f76b70b145cc951856b9bb10" name="a4f508739f76b70b145cc951856b9bb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f508739f76b70b145cc951856b9bb10">&#9670;&#160;</a></span>WRONG_PERMISSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRONG_PERMISSION&#160;&#160;&#160;-4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error number for when trying to use the file descriptor in an invalid way such as writing to F_READ file descriptor. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a157e51c85caee5bec44a2f9a4e5605e6" name="a157e51c85caee5bec44a2f9a4e5605e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157e51c85caee5bec44a2f9a4e5605e6">&#9670;&#160;</a></span>Whence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a157e51c85caee5bec44a2f9a4e5605e6">Whence</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines how the offset will be calculated when using the k_lseek method. For more detail, refer to lseek(2). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a157e51c85caee5bec44a2f9a4e5605e6ad21e659a9215dc7d9bc52f5d7e27b7cb" name="a157e51c85caee5bec44a2f9a4e5605e6ad21e659a9215dc7d9bc52f5d7e27b7cb"></a>F_SEEK_SET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a157e51c85caee5bec44a2f9a4e5605e6ab31ac29c12e35bd468f95e18263e9850" name="a157e51c85caee5bec44a2f9a4e5605e6ab31ac29c12e35bd468f95e18263e9850"></a>F_SEEK_CUR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a157e51c85caee5bec44a2f9a4e5605e6a3efde7f3f3639fd0801644753d2e5674" name="a157e51c85caee5bec44a2f9a4e5605e6a3efde7f3f3639fd0801644753d2e5674"></a>F_SEEK_END&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3fd2d5dba8f5f42be13d549b0e08a3ad" name="a3fd2d5dba8f5f42be13d549b0e08a3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd2d5dba8f5f42be13d549b0e08a3ad">&#9670;&#160;</a></span>create_directory_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="../../d8/d68/structdirectory__entries.html">directory_entries</a> * create_directory_entry </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>firstBlock</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>perm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t</td>          <td class="paramname"><span class="paramname"><em>mtime</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="../../d8/d68/structdirectory__entries.html" title="This structure stores all required information about the directory entries that are stored in the roo...">directory_entries</a> struct, initialized with the values provided by the parameters. For more information of the parameters, refer to struct <a class="el" href="../../d8/d68/structdirectory__entries.html" title="This structure stores all required information about the directory entries that are stored in the roo...">directory_entries</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the file. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the current file. </td></tr>
    <tr><td class="paramname">firstBlock</td><td>First FAT block number. </td></tr>
    <tr><td class="paramname">type</td><td>Type of the file. </td></tr>
    <tr><td class="paramname">perm</td><td>Permission of the file. </td></tr>
    <tr><td class="paramname">mtime</td><td>Last modified time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created <a class="el" href="../../d8/d68/structdirectory__entries.html" title="This structure stores all required information about the directory entries that are stored in the roo...">directory_entries</a> struct. NULL on memory allocation error. </dd></dl>

</div>
</div>
<a id="a25ad4d01d5ade905b2bfce04910a5c0d" name="a25ad4d01d5ade905b2bfce04910a5c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ad4d01d5ade905b2bfce04910a5c0d">&#9670;&#160;</a></span>create_file_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="../../d1/d06/structfile__descriptor__st.html">file_descriptor_st</a> * create_file_descriptor </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fname</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="../../d1/d06/structfile__descriptor__st.html" title="This structure stores all required information about the file descriptor.">file_descriptor_st</a> struct, initialized with the values provided by the parameters. For more information of the parameters, refer to struct <a class="el" href="../../d1/d06/structfile__descriptor__st.html" title="This structure stores all required information about the file descriptor.">file_descriptor_st</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor number. </td></tr>
    <tr><td class="paramname">fname</td><td>Name of the file. </td></tr>
    <tr><td class="paramname">mode</td><td>Either F_WRITE, F_READ, F_APPEND. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset to the start of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created <a class="el" href="../../d1/d06/structfile__descriptor__st.html" title="This structure stores all required information about the file descriptor.">file_descriptor_st</a> struct. NULL on memory allocation error. </dd></dl>

</div>
</div>
<a id="a78d95341bbd2b21ed69dd341ff47669f" name="a78d95341bbd2b21ed69dd341ff47669f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d95341bbd2b21ed69dd341ff47669f">&#9670;&#160;</a></span>does_file_exist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="../../d8/d68/structdirectory__entries.html">directory_entries</a> * does_file_exist </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper that traverses root directory block by block to check if fname file exists return: the directory entry struct with name fname (NULL if not found) also moves fs_fd to the end of the root directory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>Name of the file that we want to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8434cdce67b1512300f44ed38497c22a" name="a8434cdce67b1512300f44ed38497c22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8434cdce67b1512300f44ed38497c22a">&#9670;&#160;</a></span>does_file_exist2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">off_t does_file_exist2 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that given a files name, it outputs the offset to the directory entry or negative number if the file isn't found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>Name of the file that we want to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a580177591867f52c90932219a6c29e71" name="a580177591867f52c90932219a6c29e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580177591867f52c90932219a6c29e71">&#9670;&#160;</a></span>extend_fat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extend_fat </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>empty_fat_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend the fat region of the given file (marked by the <code>start_index</code> ) by one block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>Start fat index for the given file. </td></tr>
    <tr><td class="paramname">empty_fat_index</td><td>The first empty index of the current FAT table. Should be calculated using <a class="el" href="#addbc36d23ce41b02cb1508bf85ca24e2" title="Finds and returns the first empty fat index marked as 0x0000.">get_first_empty_fat_index()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe5ffc180d9fc063efc7127d14378b54" name="abe5ffc180d9fc063efc7127d14378b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5ffc180d9fc063efc7127d14378b54">&#9670;&#160;</a></span>get_file_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="../../d1/d06/structfile__descriptor__st.html">file_descriptor_st</a> * get_file_descriptor </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the file descriptor struct for the given file descriptor number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addbc36d23ce41b02cb1508bf85ca24e2" name="addbc36d23ce41b02cb1508bf85ca24e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbc36d23ce41b02cb1508bf85ca24e2">&#9670;&#160;</a></span>get_first_empty_fat_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_first_empty_fat_index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds and returns the first empty fat index marked as 0x0000. </p>
<dl class="section return"><dt>Returns</dt><dd>first empty fat index. </dd></dl>

</div>
</div>
<a id="ada30dc78055b7b113ff2dac9aabe4eb3" name="ada30dc78055b7b113ff2dac9aabe4eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada30dc78055b7b113ff2dac9aabe4eb3">&#9670;&#160;</a></span>is_file_name_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_file_name_valid </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the filename follows the POSIX standard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Filename.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if valid. False otherwise. </dd></dl>

</div>
</div>
<a id="ad4e9851dc3cbc61a9f8ffd36b94b9938" name="ad4e9851dc3cbc61a9f8ffd36b94b9938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e9851dc3cbc61a9f8ffd36b94b9938">&#9670;&#160;</a></span>k_change_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_change_mode </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>change</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change file mode bits. </p>
<p>The operator + causes the selected file mode bits to be added to the existing file mode bits of each file; - causes them to be removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">change</td><td>String that determines how the bits are modified. </td></tr>
    <tr><td class="paramname">filename</td><td>Name of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success. Negative number on failure. </dd></dl>

</div>
</div>
<a id="a9ecd38dc6f3a9721ab53ff9a815b5480" name="a9ecd38dc6f3a9721ab53ff9a815b5480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecd38dc6f3a9721ab53ff9a815b5480">&#9670;&#160;</a></span>k_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_close </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the file fd and return 0 on success, or a negative value on failure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor number that needs to be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative value on failure. </dd></dl>

</div>
</div>
<a id="af7f9a41e9fb0fdf97403eff276990e1f" name="af7f9a41e9fb0fdf97403eff276990e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f9a41e9fb0fdf97403eff276990e1f">&#9670;&#160;</a></span>k_count_fd_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_count_fd_num </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of currently open in the global_fd_table with the <code>name</code> as the fname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the file that we want to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90de0cbbfd37f924016dd07d60d38853" name="a90de0cbbfd37f924016dd07d60d38853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90de0cbbfd37f924016dd07d60d38853">&#9670;&#160;</a></span>k_cp_from_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_cp_from_host </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>host_source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the contents from <code>host_source</code> to <code>dest</code>. <code>dest</code> must be a file within the PENNFAT system. <code>host_source</code> is a host system file. </p>
<p><code>host_source</code> must exist. If <code>dest</code> does not exist, it will be newly created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_source</td><td>File name of source. Must be a host system file. </td></tr>
    <tr><td class="paramname">dest</td><td>File name of dest. Must be a PennFAT file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success. Negative number on failure. </dd></dl>

</div>
</div>
<a id="aaad024bf5305fa73db8c92084f8a1df0" name="aaad024bf5305fa73db8c92084f8a1df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad024bf5305fa73db8c92084f8a1df0">&#9670;&#160;</a></span>k_cp_to_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_cp_to_host </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>host_dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the contents from <code>source</code> to <code>host_dest</code> <code>source</code> must be a file within the PENNFAT system. <code>host_dest</code> is a host system file. </p>
<p><code>source</code> must exist. If <code>host_dest</code> does not exist, it will be newly created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>File name of source. Must be a PennFAT file. </td></tr>
    <tr><td class="paramname">host_dest</td><td>File name of dest. Must be a host system file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success. Negative number on failure. </dd></dl>

</div>
</div>
<a id="a82daa98d4c392b4249bfbc975be22daa" name="a82daa98d4c392b4249bfbc975be22daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82daa98d4c392b4249bfbc975be22daa">&#9670;&#160;</a></span>k_cp_within_fat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_cp_within_fat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the contents from <code>source</code> to <code>dest</code>. Both <code>source</code> and <code>dest</code> must be files within the PENNFAT system. </p>
<p><code>source</code> must exist. If <code>dest</code> does not exist, it will be newly created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>File name of source. Must be a PennFAT file. </td></tr>
    <tr><td class="paramname">dest</td><td>File name of dest. Must be a PennFAT file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success. Negative number on failure. </dd></dl>

</div>
</div>
<a id="af6d6a9bc81e4cf0788c8f1de39999c22" name="af6d6a9bc81e4cf0788c8f1de39999c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d6a9bc81e4cf0788c8f1de39999c22">&#9670;&#160;</a></span>k_get_fname_from_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * k_get_fname_from_fd </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the filename for the given file descriptor number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file name of the <code>fd</code> . NULL is <code>fd</code> is invalid. </dd></dl>

</div>
</div>
<a id="aa1a03cfc7e106d29d54196f03557b9ba" name="aa1a03cfc7e106d29d54196f03557b9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a03cfc7e106d29d54196f03557b9ba">&#9670;&#160;</a></span>k_ls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_ls </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List the file filename in the current directory. If filename is NULL, list all files in the current directory. </p>
<p>Similar to posix ls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Optional parameter. If specified, ls data for the specified file is printed </td></tr>
    <tr><td class="paramname">fd</td><td>The file descriptor you want to write the result of k_ls to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a332b4729ef52b2a3132b1aea88fa5c96" name="a332b4729ef52b2a3132b1aea88fa5c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332b4729ef52b2a3132b1aea88fa5c96">&#9670;&#160;</a></span>k_lseek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">off_t k_lseek </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>whence</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reposition the file pointer for fd to the offset relative to whence. Refer to lseek(2) for how whence interacts with the file offset. If the newly calculated offset is creater than the current size of the file, the file expands to match that offset with the newly allocated space filled with 0s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor number </td></tr>
    <tr><td class="paramname">offset</td><td>Offset value </td></tr>
    <tr><td class="paramname">whence</td><td>F_SEEK_SET, F_SEEK_CUR, and F_SEEK_END. Follows the lseek(2) whence mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off_t Newly calculated offset for <code>fd</code> </dd></dl>

</div>
</div>
<a id="a4d2cf4232cddee738996ca9ad83ea56f" name="a4d2cf4232cddee738996ca9ad83ea56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2cf4232cddee738996ca9ad83ea56f">&#9670;&#160;</a></span>k_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_open </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open file name <code>fname</code> with the mode <code>mode</code>, and return a file descriptor to that file. </p>
<p>This function opens a file specified by the file name <code>fname</code> in the mode specified by <code>mode</code> and returns a file descriptor associated with the open file that can be used for subsequent file operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the file to open. See POSIX standard for allowed names. </td></tr>
    <tr><td class="paramname">mode</td><td>The mode with which to open the file. This should specify the access mode (e.g., read, write) and other flags as defined by the operating system. Allowed modes are: write (<code>F_WRITE</code>), read (<code>F_READ</code>), and append (<code>F_APPEND</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int A non-negative file descriptor on success, or -1 on error and <code>errno</code> set.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>mode</code> parameter may only be <code>F_WRITE</code>, <code>F_READ</code>, or <code>F_APPEND</code>. Note that despite their names, write and append support both reading and writing. <code>F_APPEND</code>'s file pointer will point to the end of the file rather than the beginning. Both <code>F_WRITE</code> and <code>F_APPEND</code> will create the named file if it does not already exist.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.ibm.com/docs/en/zos/3.1.0?topic=locales-posix-portable-file-name-character-set">https://www.ibm.com/docs/en/zos/3.1.0?topic=locales-posix-portable-file-name-character-set</a></dd></dl>
<p>Possible values of <code>errno</code> are:</p><ul>
<li><code>EACCES</code> : // need to fill these in, will expand as further progress</li>
<li><code>ENAMETOOLONG</code> : </li>
</ul>

</div>
</div>
<a id="a1951ec11865274b45144d6dd6f878692" name="a1951ec11865274b45144d6dd6f878692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1951ec11865274b45144d6dd6f878692">&#9670;&#160;</a></span>k_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t k_read </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read n bytes from the file referenced by fd. On return, k_read returns the number of bytes read, 0 if EOF is reached, or a negative number on error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor number we are reading from </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes we are reading from <code>fd</code> </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer where we store the read value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ssize_t the number of bytes read, 0 if EOF is reached, or a negative number on error </dd></dl>

</div>
</div>
<a id="a08194e0542962e4d980cd9278f33c7f5" name="a08194e0542962e4d980cd9278f33c7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08194e0542962e4d980cd9278f33c7f5">&#9670;&#160;</a></span>k_read_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * k_read_all </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>read_num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all contents from the file with the file name <code>filename</code>. Outputs the contents as well as update <code>read_num</code> to the number of bytes read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the file we want to read from. </td></tr>
    <tr><td class="paramname">read_num</td><td>Pointer to an integer variable that will store the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All contents of <code>filename</code> in char* format. </dd></dl>

</div>
</div>
<a id="a85eace193c41193d1646af1a8b943200" name="a85eace193c41193d1646af1a8b943200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85eace193c41193d1646af1a8b943200">&#9670;&#160;</a></span>k_rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_rename </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename <code>source</code> to <code>dest</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source file name. </td></tr>
    <tr><td class="paramname">dest</td><td>Destination file name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success. Negative number on failure. </dd></dl>

</div>
</div>
<a id="ae8b44b3621ebb542bec49f73d19d2885" name="ae8b44b3621ebb542bec49f73d19d2885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b44b3621ebb542bec49f73d19d2885">&#9670;&#160;</a></span>k_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_unlink </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the file by freeing the FAT table and zeroing out previously existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>Name of the file we want to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success. Negative value of failure. </dd></dl>

</div>
</div>
<a id="abf487212da5b9d6ebceef678fa744ad9" name="abf487212da5b9d6ebceef678fa744ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf487212da5b9d6ebceef678fa744ad9">&#9670;&#160;</a></span>k_update_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_update_timestamp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the timestamp of the file to the current time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source file name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success. Negative number on failure. </dd></dl>

</div>
</div>
<a id="a79d2a9b65d0e04de358fe1a2cfa79baf" name="a79d2a9b65d0e04de358fe1a2cfa79baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d2a9b65d0e04de358fe1a2cfa79baf">&#9670;&#160;</a></span>k_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t k_write </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write n bytes of the string referenced by str to the file fd and increment the file pointer by n. On return, k_write returns the number of bytes written, or a negative value on error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor number we are reading to </td></tr>
    <tr><td class="paramname">str</td><td>Provided string we want to write to <code>fd</code> </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes we are writing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ssize_t number of bytes written, or a negative value on error. </dd></dl>

</div>
</div>
<a id="a2d501c304eeba5035c83c1e2a4aec4fb" name="a2d501c304eeba5035c83c1e2a4aec4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d501c304eeba5035c83c1e2a4aec4fb">&#9670;&#160;</a></span>lseek_to_root_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lseek_to_root_directory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lseek the file system's offset to the start of the root directory. </p>

</div>
</div>
<a id="a6532ad36b852dd09d641bcaac2642b9b" name="a6532ad36b852dd09d641bcaac2642b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6532ad36b852dd09d641bcaac2642b9b">&#9670;&#160;</a></span>move_to_open_de()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void move_to_open_de </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>found</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the offset to the fs_fd to the first open directory entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">found</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a70b27761c7d0bd5cd90f4fe47e569b94" name="a70b27761c7d0bd5cd90f4fe47e569b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b27761c7d0bd5cd90f4fe47e569b94">&#9670;&#160;</a></span>block_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int block_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block size of the currently mounted filesystem that is defined during the mkfs process. </p>

</div>
</div>
<a id="af69e180c878a9c8f4e45ec7dc25a062f" name="af69e180c878a9c8f4e45ec7dc25a062f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69e180c878a9c8f4e45ec7dc25a062f">&#9670;&#160;</a></span>data_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int data_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated data region size of the currently mounted filesystem. </p>

</div>
</div>
<a id="a0e52a1a113ded7f4787290edc22ad954" name="a0e52a1a113ded7f4787290edc22ad954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e52a1a113ded7f4787290edc22ad954">&#9670;&#160;</a></span>fat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t* fat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PennFAT filesystem that has been mounted to memory using the mmap(2). </p>

</div>
</div>
<a id="a6a5f2839b4852a1e8b5c0b10ec6caa5b" name="a6a5f2839b4852a1e8b5c0b10ec6caa5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5f2839b4852a1e8b5c0b10ec6caa5b">&#9670;&#160;</a></span>fat_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fat_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FAT region size of the currently mounted filesystem. </p>

</div>
</div>
<a id="a64b57b29bcc87a7b1967c7d55e7d4212" name="a64b57b29bcc87a7b1967c7d55e7d4212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b57b29bcc87a7b1967c7d55e7d4212">&#9670;&#160;</a></span>fs_fd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fs_fd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File descriptor number (host system level) for the filesystem that has been mounted to the program. </p>

</div>
</div>
<a id="a07afa4cbf62f3ce8292a6ddbcb37c8fc" name="a07afa4cbf62f3ce8292a6ddbcb37c8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07afa4cbf62f3ce8292a6ddbcb37c8fc">&#9670;&#160;</a></span>global_fd_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="../../d1/d06/structfile__descriptor__st.html">file_descriptor_st</a>** global_fd_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kernel level global file descriptor table that stores all file descriptor that has been created through out the program's runtime. </p>

</div>
</div>
<a id="af866bcf6c2272c2f6b1b7e5ad3a2e127" name="af866bcf6c2272c2f6b1b7e5ad3a2e127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af866bcf6c2272c2f6b1b7e5ad3a2e127">&#9670;&#160;</a></span>num_fat_entries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int num_fat_entries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated value of the total number of FAT entries within the currently mounted filesystem. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
