<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PennOS: src/util/sys_call.h File Reference</title>
<link rel="icon" href="../../icons8-document-50.png" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">PennOS<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">PennOS, a UNIX-like operating system.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="../../dir_b7878ad5ecbf2506f4125b9d34c97e45.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sys_call.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="../../da/d41/error_8h_source.html">error.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d5/d87/globals_8h_source.html">globals.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d0/daa/kernel_8h_source.html">kernel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d0/d4d/pennfat__kernel_8h_source.html">pennfat_kernel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d0/d8c/shellbuiltins_8h_source.html">shellbuiltins.h</a>&quot;</code><br />
</div>
<p><a href="../../db/d80/sys__call_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0985baf467c640978def72b6e0edc8bb" id="r_a0985baf467c640978def72b6e0edc8bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0985baf467c640978def72b6e0edc8bb">STATUS_EXITED</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:a0985baf467c640978def72b6e0edc8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26f0e851d5dd46ecec084f5b941acfd" id="r_ab26f0e851d5dd46ecec084f5b941acfd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab26f0e851d5dd46ecec084f5b941acfd">STATUS_STOPPED</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ab26f0e851d5dd46ecec084f5b941acfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5f3b0332fe998d13d886e4d5969b19" id="r_aad5f3b0332fe998d13d886e4d5969b19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad5f3b0332fe998d13d886e4d5969b19">STATUS_SIGNALED</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:aad5f3b0332fe998d13d886e4d5969b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1406bee782fa878df64c30b6a77c1e1" id="r_ad1406bee782fa878df64c30b6a77c1e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1406bee782fa878df64c30b6a77c1e1">P_WIFEXITED</a>(status)&#160;&#160;&#160;(((status) &amp; 0xFF) == <a class="el" href="#a0985baf467c640978def72b6e0edc8bb">STATUS_EXITED</a>)</td></tr>
<tr class="separator:ad1406bee782fa878df64c30b6a77c1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab1ade32fa50a6b4ce169bfd5a1aa53" id="r_a4ab1ade32fa50a6b4ce169bfd5a1aa53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ab1ade32fa50a6b4ce169bfd5a1aa53">P_WIFSTOPPED</a>(status)&#160;&#160;&#160;(((status) &amp; 0xFF) == <a class="el" href="#ab26f0e851d5dd46ecec084f5b941acfd">STATUS_STOPPED</a>)</td></tr>
<tr class="separator:a4ab1ade32fa50a6b4ce169bfd5a1aa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd24dcb672da49b7fef53824f098693" id="r_a7dd24dcb672da49b7fef53824f098693"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dd24dcb672da49b7fef53824f098693">P_WIFSIGNALED</a>(status)&#160;&#160;&#160;(((status) &amp; 0xFF) == <a class="el" href="#aad5f3b0332fe998d13d886e4d5969b19">STATUS_SIGNALED</a>)</td></tr>
<tr class="separator:a7dd24dcb672da49b7fef53824f098693"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9df1ce5034a7614c2c55bc05500f5991" id="r_a9df1ce5034a7614c2c55bc05500f5991"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991">log_message_t</a> { <br />
&#160;&#160;<a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991ad594ab9bf88656efe790917210429046">SCHEDULE</a>
, <a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991a473b49382a20dcc5b0ee10ddbc6338b4">CREATE</a>
, <a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991a7a10b5d68d31711288e1fe0fa17dbf4f">EXIT</a>
, <a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991a480882f626731b7fa7fc7caf12d8cb66">SIGNAL</a>
, <br />
&#160;&#160;<a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991a5dfb36109b24f39d54d5c3f48f53def8">ZOMBIE</a>
, <a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991a4054f1e964953e9b2236beb36a714f7f">ORPHAN</a>
, <a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991a79a322ccb4b29b85b3cab52dbccefd17">WAIT</a>
, <a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991ab31411fab4fd2cab988d78995b9e888f">NICE</a>
, <br />
&#160;&#160;<a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991a02fc27068fe9a3c151ffcc08ec5bb65d">BLOCK</a>
, <a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991a2cf317a25bb87a47bcc72b2ac633945d">UNBLOCK</a>
, <a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991a679ee5320d66c8322e310daeb2ee99b8">STOP</a>
, <a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991a49959dd441dcda75d6898cf2c68fb374">CONTINUE</a>
<br />
 }</td></tr>
<tr class="memdesc:a9df1ce5034a7614c2c55bc05500f5991"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an enum used to specify which log message should be added for <a class="el" href="d8/d74/sys__call_8c.html#a1db57eb907f680ab844066357b793d5f">s_write_log</a>.  <a href="#a9df1ce5034a7614c2c55bc05500f5991">More...</a><br /></td></tr>
<tr class="separator:a9df1ce5034a7614c2c55bc05500f5991"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a43b789c710ba1501bcd8cf54e4382e50" id="r_a43b789c710ba1501bcd8cf54e4382e50"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43b789c710ba1501bcd8cf54e4382e50">s_spawn</a> (void *(*func)(void *), char *argv[], int fd0, int fd1)</td></tr>
<tr class="memdesc:a43b789c710ba1501bcd8cf54e4382e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a child process that executes the function <code>func</code>. The child will retain some attributes of the parent.  <br /></td></tr>
<tr class="separator:a43b789c710ba1501bcd8cf54e4382e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b97025761b7f8ad7e59b641cad08d6" id="r_a62b97025761b7f8ad7e59b641cad08d6"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62b97025761b7f8ad7e59b641cad08d6">s_spawn_nice</a> (void *(*func)(void *), char *argv[], int fd0, int fd1, unsigned int <a class="el" href="../../d8/d75/pennos_8c.html#a2e0cca4a43c21259b881d59c96c74fe0">priority</a>)</td></tr>
<tr class="memdesc:a62b97025761b7f8ad7e59b641cad08d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a child process that executes the function <code>func</code>, with a specified priority. This is an exact copy of <a class="el" href="../../d8/d74/sys__call_8c.html#a43b789c710ba1501bcd8cf54e4382e50">s_spawn</a> except that the priority of the created process can be specificed at creation.  <br /></td></tr>
<tr class="separator:a62b97025761b7f8ad7e59b641cad08d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0c6c4ae69799354d707ff57ac925d3" id="r_a3c0c6c4ae69799354d707ff57ac925d3"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c0c6c4ae69799354d707ff57ac925d3">s_waitpid</a> (pid_t pid, int *wstatus, bool <a class="el" href="../../d3/db6/stress_8c.html#aaacb1f06dd4ec309398fb76d008fdc90">nohang</a>)</td></tr>
<tr class="memdesc:a3c0c6c4ae69799354d707ff57ac925d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a child of the calling process, until it changes state. If <code>nohang</code> is true, this will not block the calling process and return immediately.  <br /></td></tr>
<tr class="separator:a3c0c6c4ae69799354d707ff57ac925d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e6794b108eea25459bd7fe31de4e76" id="r_a18e6794b108eea25459bd7fe31de4e76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18e6794b108eea25459bd7fe31de4e76">s_kill</a> (pid_t pid, int signal)</td></tr>
<tr class="memdesc:a18e6794b108eea25459bd7fe31de4e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to a particular process.  <br /></td></tr>
<tr class="separator:a18e6794b108eea25459bd7fe31de4e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964c6f7d6a06dddfd15cbd2d348dbd59" id="r_a964c6f7d6a06dddfd15cbd2d348dbd59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a964c6f7d6a06dddfd15cbd2d348dbd59">s_reap_all_child</a> (<a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *parent)</td></tr>
<tr class="memdesc:a964c6f7d6a06dddfd15cbd2d348dbd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses recursion to reap all children of specified parent.  <br /></td></tr>
<tr class="separator:a964c6f7d6a06dddfd15cbd2d348dbd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c8865d5bf1ca946e5b5405190f6690" id="r_a53c8865d5bf1ca946e5b5405190f6690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53c8865d5bf1ca946e5b5405190f6690">s_exit</a> (void)</td></tr>
<tr class="memdesc:a53c8865d5bf1ca946e5b5405190f6690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally exit the calling process.  <br /></td></tr>
<tr class="separator:a53c8865d5bf1ca946e5b5405190f6690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac711d33fcf2573a590b224b6debab996" id="r_ac711d33fcf2573a590b224b6debab996"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac711d33fcf2573a590b224b6debab996">s_nice</a> (pid_t pid, int <a class="el" href="../../d8/d75/pennos_8c.html#a2e0cca4a43c21259b881d59c96c74fe0">priority</a>)</td></tr>
<tr class="memdesc:ac711d33fcf2573a590b224b6debab996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of the specified thread.  <br /></td></tr>
<tr class="separator:ac711d33fcf2573a590b224b6debab996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8fdff50e5b9c5fa8559fe294e4243f" id="r_a0b8fdff50e5b9c5fa8559fe294e4243f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b8fdff50e5b9c5fa8559fe294e4243f">s_sleep</a> (unsigned int ticks)</td></tr>
<tr class="memdesc:a0b8fdff50e5b9c5fa8559fe294e4243f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends execution of the calling proces for a specified number of clock ticks.  <br /></td></tr>
<tr class="separator:a0b8fdff50e5b9c5fa8559fe294e4243f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3aeae7e3fb489c4cf3c4dc3911bbce" id="r_a1a3aeae7e3fb489c4cf3c4dc3911bbce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a3aeae7e3fb489c4cf3c4dc3911bbce">s_busy</a> (void)</td></tr>
<tr class="memdesc:a1a3aeae7e3fb489c4cf3c4dc3911bbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends execution of the calling process for an unspecified amount of time.  <br /></td></tr>
<tr class="separator:a1a3aeae7e3fb489c4cf3c4dc3911bbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9116ac84aeec3a4717eab9aa7137080e" id="r_a9116ac84aeec3a4717eab9aa7137080e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9116ac84aeec3a4717eab9aa7137080e">s_spawn_and_wait</a> (void *(*func)(void *), char *argv[], int fd0, int fd1, bool <a class="el" href="../../d3/db6/stress_8c.html#aaacb1f06dd4ec309398fb76d008fdc90">nohang</a>, unsigned int <a class="el" href="../../d8/d75/pennos_8c.html#a2e0cca4a43c21259b881d59c96c74fe0">priority</a>)</td></tr>
<tr class="memdesc:a9116ac84aeec3a4717eab9aa7137080e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns and waits for a process, combining s_spawn and s_waitpid.  <br /></td></tr>
<tr class="separator:a9116ac84aeec3a4717eab9aa7137080e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ff16131dec7dc8b25686329a19d0db" id="r_a35ff16131dec7dc8b25686329a19d0db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35ff16131dec7dc8b25686329a19d0db">s_find_process</a> (pid_t pid)</td></tr>
<tr class="memdesc:a35ff16131dec7dc8b25686329a19d0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a process in any state.  <br /></td></tr>
<tr class="separator:a35ff16131dec7dc8b25686329a19d0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ef4dc77a6071976f7d93759d48afa6" id="r_a09ef4dc77a6071976f7d93759d48afa6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09ef4dc77a6071976f7d93759d48afa6">s_remove_process</a> (pid_t pid)</td></tr>
<tr class="memdesc:a09ef4dc77a6071976f7d93759d48afa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a process in any state.  <br /></td></tr>
<tr class="separator:a09ef4dc77a6071976f7d93759d48afa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5efee98239591e685e3ae7da8203b21" id="r_ab5efee98239591e685e3ae7da8203b21"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5efee98239591e685e3ae7da8203b21">s_function_from_string</a> (char *program)</td></tr>
<tr class="separator:ab5efee98239591e685e3ae7da8203b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db57eb907f680ab844066357b793d5f" id="r_a1db57eb907f680ab844066357b793d5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1db57eb907f680ab844066357b793d5f">s_write_log</a> (<a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991">log_message_t</a> logtype, <a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *proc, unsigned int old_nice)</td></tr>
<tr class="separator:a1db57eb907f680ab844066357b793d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc95330d937650d14281e3d6041f284" id="r_a7cc95330d937650d14281e3d6041f284"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cc95330d937650d14281e3d6041f284">s_move_process</a> (<a class="el" href="../../de/d82/structCircularList.html">CircularList</a> *destination, pid_t pid)</td></tr>
<tr class="separator:a7cc95330d937650d14281e3d6041f284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc68daae1d550a0993e99d583b0c1264" id="r_abc68daae1d550a0993e99d583b0c1264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc68daae1d550a0993e99d583b0c1264">s_zombie</a> (pid_t pid)</td></tr>
<tr class="separator:abc68daae1d550a0993e99d583b0c1264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e11484cfd56821c3e9a1fa43aafcf0" id="r_a31e11484cfd56821c3e9a1fa43aafcf0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31e11484cfd56821c3e9a1fa43aafcf0">s_fg</a> (<a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *proc)</td></tr>
<tr class="separator:a31e11484cfd56821c3e9a1fa43aafcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd0bc17589ba38590b19d8256ffee4f" id="r_a3dd0bc17589ba38590b19d8256ffee4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dd0bc17589ba38590b19d8256ffee4f">s_bg_wait</a> (<a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *proc)</td></tr>
<tr class="memdesc:a3dd0bc17589ba38590b19d8256ffee4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks status of background processes with waitpid(nohang)  <br /></td></tr>
<tr class="separator:a3dd0bc17589ba38590b19d8256ffee4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e87f593f5c2f59d7a90958b3e51751d" id="r_a2e87f593f5c2f59d7a90958b3e51751d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e87f593f5c2f59d7a90958b3e51751d">s_print_process</a> (<a class="el" href="../../de/d82/structCircularList.html">CircularList</a> *list)</td></tr>
<tr class="separator:a2e87f593f5c2f59d7a90958b3e51751d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0c2e47d0948979e7be9350582158c8" id="r_a4e0c2e47d0948979e7be9350582158c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e0c2e47d0948979e7be9350582158c8">s_print_jobs</a> (<a class="el" href="../../de/d82/structCircularList.html">CircularList</a> *list)</td></tr>
<tr class="separator:a4e0c2e47d0948979e7be9350582158c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec6e61720e05918efefeab347e950f3" id="r_afec6e61720e05918efefeab347e950f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afec6e61720e05918efefeab347e950f3">s_open</a> (const char *fname, int mode)</td></tr>
<tr class="memdesc:afec6e61720e05918efefeab347e950f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">open a file name fname with the mode mode and return a file descriptor. The allowed modes are as follows:  <br /></td></tr>
<tr class="separator:afec6e61720e05918efefeab347e950f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcf52e63af8002a5d7c02774ee0578f" id="r_afdcf52e63af8002a5d7c02774ee0578f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdcf52e63af8002a5d7c02774ee0578f">s_read</a> (int fd, int n, char *buf)</td></tr>
<tr class="memdesc:afdcf52e63af8002a5d7c02774ee0578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">read n bytes from the file referenced by fd. On return, s_read returns the number of bytes read, 0 if EOF is reached, or a negative number on error. A kernel level read should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes.  <br /></td></tr>
<tr class="separator:afdcf52e63af8002a5d7c02774ee0578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3317435b4bd7309160538fc5d730eb9" id="r_ad3317435b4bd7309160538fc5d730eb9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3317435b4bd7309160538fc5d730eb9">s_write</a> (int fd, const char *str, int n)</td></tr>
<tr class="memdesc:ad3317435b4bd7309160538fc5d730eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">write n bytes of the string referenced by str to the file fd and increment the file pointer by n. On return, s_write returns the number of bytes written, or a negative value on error. Note that this writes bytes not chars, these can be anything, even '\0' A kernel level write should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes.  <br /></td></tr>
<tr class="separator:ad3317435b4bd7309160538fc5d730eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee856dbd0706f79a440d1e98b42d32d" id="r_a1ee856dbd0706f79a440d1e98b42d32d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ee856dbd0706f79a440d1e98b42d32d">s_close</a> (int fd)</td></tr>
<tr class="memdesc:a1ee856dbd0706f79a440d1e98b42d32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">close the file fd and return 0 on success, or a negative value on failure. A kernel level close should occur, and on success the local process’ file descriptor table should be cleaned up appropriately.  <br /></td></tr>
<tr class="separator:a1ee856dbd0706f79a440d1e98b42d32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395873f1de0b89a686d438580ba5dcf7" id="r_a395873f1de0b89a686d438580ba5dcf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a395873f1de0b89a686d438580ba5dcf7">s_unlink</a> (const char *fname)</td></tr>
<tr class="separator:a395873f1de0b89a686d438580ba5dcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21f611f4fb486935d9ad2915a529d3b" id="r_ac21f611f4fb486935d9ad2915a529d3b"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac21f611f4fb486935d9ad2915a529d3b">s_lseek</a> (int fd, int offset, int whence)</td></tr>
<tr class="memdesc:ac21f611f4fb486935d9ad2915a529d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">reposition the file pointer for fd to the offset relative to whence. You must also implement the constants F_SEEK_SET, F_SEEK_CUR, and F_SEEK_END, which reference similar file whences as their similarly named counterparts in lseek(2). A kernel level lseek should occur, and necessary changes to the calling process’ file descriptor table will be necessary.  <br /></td></tr>
<tr class="separator:ac21f611f4fb486935d9ad2915a529d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae166ac7970869bda5550149e8771c3af" id="r_ae166ac7970869bda5550149e8771c3af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae166ac7970869bda5550149e8771c3af">s_ls</a> (const char *filename, int fd)</td></tr>
<tr class="memdesc:ae166ac7970869bda5550149e8771c3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the file filename in the current directory. If filename is NULL, list all files in the current directory. Before EC implementations, this should be very simple and could literally be a call a similar k_function.  <br /></td></tr>
<tr class="separator:ae166ac7970869bda5550149e8771c3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b25be5ab040f60070ff9ea839648be" id="r_a18b25be5ab040f60070ff9ea839648be"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18b25be5ab040f60070ff9ea839648be">s_read_all</a> (const char *filename, int *read_num)</td></tr>
<tr class="separator:a18b25be5ab040f60070ff9ea839648be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2638b24106c052e0a513643f712e8d00" id="r_a2638b24106c052e0a513643f712e8d00"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2638b24106c052e0a513643f712e8d00">s_get_fname_from_fd</a> (int fd)</td></tr>
<tr class="separator:a2638b24106c052e0a513643f712e8d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40c873ca412b774e2fc1b59527538be" id="r_ab40c873ca412b774e2fc1b59527538be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab40c873ca412b774e2fc1b59527538be">s_update_timestamp</a> (const char *source)</td></tr>
<tr class="separator:ab40c873ca412b774e2fc1b59527538be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b8546b3350e1602c1574b1b0cb58d0" id="r_ae8b8546b3350e1602c1574b1b0cb58d0"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8b8546b3350e1602c1574b1b0cb58d0">s_does_file_exist2</a> (const char *fname)</td></tr>
<tr class="separator:ae8b8546b3350e1602c1574b1b0cb58d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea2dcf94b9a35c86a67cf6ec97fd21d" id="r_aeea2dcf94b9a35c86a67cf6ec97fd21d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeea2dcf94b9a35c86a67cf6ec97fd21d">s_rename</a> (const char *source, const char *dest)</td></tr>
<tr class="separator:aeea2dcf94b9a35c86a67cf6ec97fd21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d71eb90d0b9786bec0302347f5a99f" id="r_a92d71eb90d0b9786bec0302347f5a99f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92d71eb90d0b9786bec0302347f5a99f">s_change_mode</a> (const char *change, const char *filename)</td></tr>
<tr class="separator:a92d71eb90d0b9786bec0302347f5a99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55b8ad7785acad109a35a819e415622" id="r_ad55b8ad7785acad109a35a819e415622"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad55b8ad7785acad109a35a819e415622">s_cp_within_fat</a> (char *source, char *dest)</td></tr>
<tr class="separator:ad55b8ad7785acad109a35a819e415622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494917a8ce36ad19470a2116e57a1bc3" id="r_a494917a8ce36ad19470a2116e57a1bc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a494917a8ce36ad19470a2116e57a1bc3">s_cp_to_host</a> (char *source, char *host_dest)</td></tr>
<tr class="separator:a494917a8ce36ad19470a2116e57a1bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2fd1371e1cd60d964afd80eb89943e" id="r_a1e2fd1371e1cd60d964afd80eb89943e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e2fd1371e1cd60d964afd80eb89943e">s_cp_from_host</a> (char *host_source, char *dest)</td></tr>
<tr class="separator:a1e2fd1371e1cd60d964afd80eb89943e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad1406bee782fa878df64c30b6a77c1e1" name="ad1406bee782fa878df64c30b6a77c1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1406bee782fa878df64c30b6a77c1e1">&#9670;&#160;</a></span>P_WIFEXITED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define P_WIFEXITED</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">status</span></td><td>)</td>
          <td>&#160;&#160;&#160;(((status) &amp; 0xFF) == <a class="el" href="#a0985baf467c640978def72b6e0edc8bb">STATUS_EXITED</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dd24dcb672da49b7fef53824f098693" name="a7dd24dcb672da49b7fef53824f098693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd24dcb672da49b7fef53824f098693">&#9670;&#160;</a></span>P_WIFSIGNALED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define P_WIFSIGNALED</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">status</span></td><td>)</td>
          <td>&#160;&#160;&#160;(((status) &amp; 0xFF) == <a class="el" href="#aad5f3b0332fe998d13d886e4d5969b19">STATUS_SIGNALED</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ab1ade32fa50a6b4ce169bfd5a1aa53" name="a4ab1ade32fa50a6b4ce169bfd5a1aa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab1ade32fa50a6b4ce169bfd5a1aa53">&#9670;&#160;</a></span>P_WIFSTOPPED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define P_WIFSTOPPED</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">status</span></td><td>)</td>
          <td>&#160;&#160;&#160;(((status) &amp; 0xFF) == <a class="el" href="#ab26f0e851d5dd46ecec084f5b941acfd">STATUS_STOPPED</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0985baf467c640978def72b6e0edc8bb" name="a0985baf467c640978def72b6e0edc8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0985baf467c640978def72b6e0edc8bb">&#9670;&#160;</a></span>STATUS_EXITED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATUS_EXITED&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad5f3b0332fe998d13d886e4d5969b19" name="aad5f3b0332fe998d13d886e4d5969b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5f3b0332fe998d13d886e4d5969b19">&#9670;&#160;</a></span>STATUS_SIGNALED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATUS_SIGNALED&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab26f0e851d5dd46ecec084f5b941acfd" name="ab26f0e851d5dd46ecec084f5b941acfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26f0e851d5dd46ecec084f5b941acfd">&#9670;&#160;</a></span>STATUS_STOPPED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATUS_STOPPED&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9df1ce5034a7614c2c55bc05500f5991" name="a9df1ce5034a7614c2c55bc05500f5991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df1ce5034a7614c2c55bc05500f5991">&#9670;&#160;</a></span>log_message_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991">log_message_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an enum used to specify which log message should be added for <a class="el" href="../../d8/d74/sys__call_8c.html#a1db57eb907f680ab844066357b793d5f">s_write_log</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991ad594ab9bf88656efe790917210429046" name="a9df1ce5034a7614c2c55bc05500f5991ad594ab9bf88656efe790917210429046"></a>SCHEDULE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991a473b49382a20dcc5b0ee10ddbc6338b4" name="a9df1ce5034a7614c2c55bc05500f5991a473b49382a20dcc5b0ee10ddbc6338b4"></a>CREATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991a7a10b5d68d31711288e1fe0fa17dbf4f" name="a9df1ce5034a7614c2c55bc05500f5991a7a10b5d68d31711288e1fe0fa17dbf4f"></a>EXIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991a480882f626731b7fa7fc7caf12d8cb66" name="a9df1ce5034a7614c2c55bc05500f5991a480882f626731b7fa7fc7caf12d8cb66"></a>SIGNAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991a5dfb36109b24f39d54d5c3f48f53def8" name="a9df1ce5034a7614c2c55bc05500f5991a5dfb36109b24f39d54d5c3f48f53def8"></a>ZOMBIE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991a4054f1e964953e9b2236beb36a714f7f" name="a9df1ce5034a7614c2c55bc05500f5991a4054f1e964953e9b2236beb36a714f7f"></a>ORPHAN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991a79a322ccb4b29b85b3cab52dbccefd17" name="a9df1ce5034a7614c2c55bc05500f5991a79a322ccb4b29b85b3cab52dbccefd17"></a>WAIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991ab31411fab4fd2cab988d78995b9e888f" name="a9df1ce5034a7614c2c55bc05500f5991ab31411fab4fd2cab988d78995b9e888f"></a>NICE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991a02fc27068fe9a3c151ffcc08ec5bb65d" name="a9df1ce5034a7614c2c55bc05500f5991a02fc27068fe9a3c151ffcc08ec5bb65d"></a>BLOCK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991a2cf317a25bb87a47bcc72b2ac633945d" name="a9df1ce5034a7614c2c55bc05500f5991a2cf317a25bb87a47bcc72b2ac633945d"></a>UNBLOCK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991a679ee5320d66c8322e310daeb2ee99b8" name="a9df1ce5034a7614c2c55bc05500f5991a679ee5320d66c8322e310daeb2ee99b8"></a>STOP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9df1ce5034a7614c2c55bc05500f5991a49959dd441dcda75d6898cf2c68fb374" name="a9df1ce5034a7614c2c55bc05500f5991a49959dd441dcda75d6898cf2c68fb374"></a>CONTINUE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3dd0bc17589ba38590b19d8256ffee4f" name="a3dd0bc17589ba38590b19d8256ffee4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd0bc17589ba38590b19d8256ffee4f">&#9670;&#160;</a></span>s_bg_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_bg_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *</td>          <td class="paramname"><span class="paramname"><em>proc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks status of background processes with waitpid(nohang) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a1a3aeae7e3fb489c4cf3c4dc3911bbce" name="a1a3aeae7e3fb489c4cf3c4dc3911bbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3aeae7e3fb489c4cf3c4dc3911bbce">&#9670;&#160;</a></span>s_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_busy </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspends execution of the calling process for an unspecified amount of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">void.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Returns 0 on success, -1 on failure and sets errno. </dd></dl>

</div>
</div>
<a id="a92d71eb90d0b9786bec0302347f5a99f" name="a92d71eb90d0b9786bec0302347f5a99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d71eb90d0b9786bec0302347f5a99f">&#9670;&#160;</a></span>s_change_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_change_mode </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>change</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ee856dbd0706f79a440d1e98b42d32d" name="a1ee856dbd0706f79a440d1e98b42d32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee856dbd0706f79a440d1e98b42d32d">&#9670;&#160;</a></span>s_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_close </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>close the file fd and return 0 on success, or a negative value on failure. A kernel level close should occur, and on success the local process’ file descriptor table should be cleaned up appropriately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a1e2fd1371e1cd60d964afd80eb89943e" name="a1e2fd1371e1cd60d964afd80eb89943e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2fd1371e1cd60d964afd80eb89943e">&#9670;&#160;</a></span>s_cp_from_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_cp_from_host </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>host_source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a494917a8ce36ad19470a2116e57a1bc3" name="a494917a8ce36ad19470a2116e57a1bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494917a8ce36ad19470a2116e57a1bc3">&#9670;&#160;</a></span>s_cp_to_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_cp_to_host </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>host_dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad55b8ad7785acad109a35a819e415622" name="ad55b8ad7785acad109a35a819e415622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55b8ad7785acad109a35a819e415622">&#9670;&#160;</a></span>s_cp_within_fat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_cp_within_fat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8b8546b3350e1602c1574b1b0cb58d0" name="ae8b8546b3350e1602c1574b1b0cb58d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b8546b3350e1602c1574b1b0cb58d0">&#9670;&#160;</a></span>s_does_file_exist2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">off_t s_does_file_exist2 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53c8865d5bf1ca946e5b5405190f6690" name="a53c8865d5bf1ca946e5b5405190f6690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c8865d5bf1ca946e5b5405190f6690">&#9670;&#160;</a></span>s_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void s_exit </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally exit the calling process. </p>
<p>This will set the process state to zombied, adjust its state within the scheduler structures, and kill all child proceseses. (not done). </p>

</div>
</div>
<a id="a31e11484cfd56821c3e9a1fa43aafcf0" name="a31e11484cfd56821c3e9a1fa43aafcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e11484cfd56821c3e9a1fa43aafcf0">&#9670;&#160;</a></span>s_fg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_fg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *</td>          <td class="paramname"><span class="paramname"><em>proc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>random number to convert int to string</p>

</div>
</div>
<a id="a35ff16131dec7dc8b25686329a19d0db" name="a35ff16131dec7dc8b25686329a19d0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ff16131dec7dc8b25686329a19d0db">&#9670;&#160;</a></span>s_find_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> * s_find_process </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a process in any state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcb_t* </dd></dl>

</div>
</div>
<a id="ab5efee98239591e685e3ae7da8203b21" name="ab5efee98239591e685e3ae7da8203b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5efee98239591e685e3ae7da8203b21">&#9670;&#160;</a></span>s_function_from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * s_function_from_string </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>program</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2638b24106c052e0a513643f712e8d00" name="a2638b24106c052e0a513643f712e8d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2638b24106c052e0a513643f712e8d00">&#9670;&#160;</a></span>s_get_fname_from_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * s_get_fname_from_fd </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18e6794b108eea25459bd7fe31de4e76" name="a18e6794b108eea25459bd7fe31de4e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e6794b108eea25459bd7fe31de4e76">&#9670;&#160;</a></span>s_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_kill </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>signal</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a signal to a particular process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Process ID of the target proces. </td></tr>
    <tr><td class="paramname">signal</td><td>Signal number to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="ae166ac7970869bda5550149e8771c3af" name="ae166ac7970869bda5550149e8771c3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae166ac7970869bda5550149e8771c3af">&#9670;&#160;</a></span>s_ls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void s_ls </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List the file filename in the current directory. If filename is NULL, list all files in the current directory. Before EC implementations, this should be very simple and could literally be a call a similar k_function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac21f611f4fb486935d9ad2915a529d3b" name="ac21f611f4fb486935d9ad2915a529d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21f611f4fb486935d9ad2915a529d3b">&#9670;&#160;</a></span>s_lseek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">off_t s_lseek </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>whence</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reposition the file pointer for fd to the offset relative to whence. You must also implement the constants F_SEEK_SET, F_SEEK_CUR, and F_SEEK_END, which reference similar file whences as their similarly named counterparts in lseek(2). A kernel level lseek should occur, and necessary changes to the calling process’ file descriptor table will be necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td></td></tr>
    <tr><td class="paramname">offset</td><td></td></tr>
    <tr><td class="paramname">whence</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cc95330d937650d14281e3d6041f284" name="a7cc95330d937650d14281e3d6041f284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc95330d937650d14281e3d6041f284">&#9670;&#160;</a></span>s_move_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_move_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d82/structCircularList.html">CircularList</a> *</td>          <td class="paramname"><span class="paramname"><em>destination</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac711d33fcf2573a590b224b6debab996" name="ac711d33fcf2573a590b224b6debab996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac711d33fcf2573a590b224b6debab996">&#9670;&#160;</a></span>s_nice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_nice </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Process ID of the target thread. </td></tr>
    <tr><td class="paramname">priority</td><td>The new priorty value of the thread (0, 1, or 2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="afec6e61720e05918efefeab347e950f3" name="afec6e61720e05918efefeab347e950f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec6e61720e05918efefeab347e950f3">&#9670;&#160;</a></span>s_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_open </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>open a file name fname with the mode mode and return a file descriptor. The allowed modes are as follows: </p>
<p>F_WRITE - writing and reading, truncates if the file exists, or creates it if it does not exist. Only one instance of a file can be opened in F_WRITE mode; error if PennOS attempts to open a file in F_WRITE mode more than once F_READ - open the file for reading only, return an error if the file does not exist F_APPEND - open the file for reading and writing but does not truncate the file if exists; additionally, the file pointer references the end of the file.</p>
<p>s_open returns a file descriptor on success and a negative value on error. This open will initially be done at the kernel level, using a more intricate and already-implemented kernel level function. If the kernel level function succeeds and returns a fd, the user level function should also somehow keep track that such file descriptor is managed by the calling process. This can be done in multiple ways.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td></td></tr>
    <tr><td class="paramname">mode</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a4e0c2e47d0948979e7be9350582158c8" name="a4e0c2e47d0948979e7be9350582158c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0c2e47d0948979e7be9350582158c8">&#9670;&#160;</a></span>s_print_jobs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_print_jobs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d82/structCircularList.html">CircularList</a> *</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e87f593f5c2f59d7a90958b3e51751d" name="a2e87f593f5c2f59d7a90958b3e51751d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e87f593f5c2f59d7a90958b3e51751d">&#9670;&#160;</a></span>s_print_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_print_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d82/structCircularList.html">CircularList</a> *</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afdcf52e63af8002a5d7c02774ee0578f" name="afdcf52e63af8002a5d7c02774ee0578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcf52e63af8002a5d7c02774ee0578f">&#9670;&#160;</a></span>s_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t s_read </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read n bytes from the file referenced by fd. On return, s_read returns the number of bytes read, 0 if EOF is reached, or a negative number on error. A kernel level read should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ssize_t </dd></dl>

</div>
</div>
<a id="a18b25be5ab040f60070ff9ea839648be" name="a18b25be5ab040f60070ff9ea839648be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b25be5ab040f60070ff9ea839648be">&#9670;&#160;</a></span>s_read_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * s_read_all </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>read_num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a964c6f7d6a06dddfd15cbd2d348dbd59" name="a964c6f7d6a06dddfd15cbd2d348dbd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964c6f7d6a06dddfd15cbd2d348dbd59">&#9670;&#160;</a></span>s_reap_all_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void s_reap_all_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses recursion to reap all children of specified parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>PCB of the parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09ef4dc77a6071976f7d93759d48afa6" name="a09ef4dc77a6071976f7d93759d48afa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ef4dc77a6071976f7d93759d48afa6">&#9670;&#160;</a></span>s_remove_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_remove_process </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a process in any state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="aeea2dcf94b9a35c86a67cf6ec97fd21d" name="aeea2dcf94b9a35c86a67cf6ec97fd21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea2dcf94b9a35c86a67cf6ec97fd21d">&#9670;&#160;</a></span>s_rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_rename </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b8fdff50e5b9c5fa8559fe294e4243f" name="a0b8fdff50e5b9c5fa8559fe294e4243f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8fdff50e5b9c5fa8559fe294e4243f">&#9670;&#160;</a></span>s_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>ticks</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspends execution of the calling proces for a specified number of clock ticks. </p>
<p>This function is analogous to <code>sleep(3)</code> in Linux, with the behavior that the system clock continues to tick even if the call is interrupted. The sleep can be interrupted by a P_SIGTERM signal, after which the function will return prematurely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticks</td><td>Duration of the sleep in system clock ticks. Must be greater than 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Returns 0 on success, -1 on failure and sets errno. </dd></dl>

</div>
</div>
<a id="a43b789c710ba1501bcd8cf54e4382e50" name="a43b789c710ba1501bcd8cf54e4382e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b789c710ba1501bcd8cf54e4382e50">&#9670;&#160;</a></span>s_spawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t s_spawn </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *)</td>          <td class="paramname"><span class="paramname"><em>func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a child process that executes the function <code>func</code>. The child will retain some attributes of the parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to be executed by the child process. </td></tr>
    <tr><td class="paramname">argv</td><td>Null-terminated array of args, including the command name as argv[0]. </td></tr>
    <tr><td class="paramname">fd0</td><td>Input file descriptor. </td></tr>
    <tr><td class="paramname">fd1</td><td>Output file descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pid_t The process ID of the created child process. // need to define error output? </dd></dl>

</div>
</div>
<a id="a9116ac84aeec3a4717eab9aa7137080e" name="a9116ac84aeec3a4717eab9aa7137080e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9116ac84aeec3a4717eab9aa7137080e">&#9670;&#160;</a></span>s_spawn_and_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_spawn_and_wait </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *)</td>          <td class="paramname"><span class="paramname"><em>func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nohang</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns and waits for a process, combining s_spawn and s_waitpid. </p>
<p>Spawns and waits for a process.</p>
<p>This generalizes the control loop of spawning a process, waiting on it via s_waitpid (depending on whether it was a background process) and then cleaning it up, into one function call. Used to call most shell functions (b_functions).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be executed. </td></tr>
    <tr><td class="paramname">argv</td><td>The argument to that function that is passed into the <a class="el" href="../../d8/d74/sys__call_8c.html#a43b789c710ba1501bcd8cf54e4382e50">s_spawn</a> call. </td></tr>
    <tr><td class="paramname">fd0</td><td>Input file descriptor. </td></tr>
    <tr><td class="paramname">fd1</td><td>Output file descriptor. </td></tr>
    <tr><td class="paramname">nohang</td><td>Whether or not to wait on the process or immediately proceed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Returns 0 on success, -1 on failure and sets errno.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td></td></tr>
    <tr><td class="paramname">argv</td><td></td></tr>
    <tr><td class="paramname">fd0</td><td></td></tr>
    <tr><td class="paramname">fd1</td><td></td></tr>
    <tr><td class="paramname">nohang</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int</dd></dl>
<p>Spawns and waits for a process, combining s_spawn and s_waitpid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td></td></tr>
    <tr><td class="paramname">argv</td><td></td></tr>
    <tr><td class="paramname">fd0</td><td></td></tr>
    <tr><td class="paramname">fd1</td><td></td></tr>
    <tr><td class="paramname">nohang</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>
<p>or status signaled?</p>

</div>
</div>
<a id="a62b97025761b7f8ad7e59b641cad08d6" name="a62b97025761b7f8ad7e59b641cad08d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b97025761b7f8ad7e59b641cad08d6">&#9670;&#160;</a></span>s_spawn_nice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t s_spawn_nice </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *)</td>          <td class="paramname"><span class="paramname"><em>func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a child process that executes the function <code>func</code>, with a specified priority. This is an exact copy of <a class="el" href="../../d8/d74/sys__call_8c.html#a43b789c710ba1501bcd8cf54e4382e50">s_spawn</a> except that the priority of the created process can be specificed at creation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to be executed by the child process. </td></tr>
    <tr><td class="paramname">argv</td><td>Null-terminated array of args, including the command name as argv[0]. </td></tr>
    <tr><td class="paramname">fd0</td><td>Input file descriptor. </td></tr>
    <tr><td class="paramname">fd1</td><td>Output file descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pid_t The process ID of the created child process. </dd></dl>

</div>
</div>
<a id="a395873f1de0b89a686d438580ba5dcf7" name="a395873f1de0b89a686d438580ba5dcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395873f1de0b89a686d438580ba5dcf7">&#9670;&#160;</a></span>s_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_unlink </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="ab40c873ca412b774e2fc1b59527538be" name="ab40c873ca412b774e2fc1b59527538be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40c873ca412b774e2fc1b59527538be">&#9670;&#160;</a></span>s_update_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_update_timestamp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c0c6c4ae69799354d707ff57ac925d3" name="a3c0c6c4ae69799354d707ff57ac925d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0c6c4ae69799354d707ff57ac925d3">&#9670;&#160;</a></span>s_waitpid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t s_waitpid </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>wstatus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nohang</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a child of the calling process, until it changes state. If <code>nohang</code> is true, this will not block the calling process and return immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Process ID of the child to wait for. </td></tr>
    <tr><td class="paramname">wstatus</td><td>Pointer to an integer variable where the status will be stored. </td></tr>
    <tr><td class="paramname">nohang</td><td>If true, return immediately if no child has exited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pid_t The process ID of the child which has changed state on success, -1 on error. </dd></dl>

</div>
</div>
<a id="ad3317435b4bd7309160538fc5d730eb9" name="ad3317435b4bd7309160538fc5d730eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3317435b4bd7309160538fc5d730eb9">&#9670;&#160;</a></span>s_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t s_write </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write n bytes of the string referenced by str to the file fd and increment the file pointer by n. On return, s_write returns the number of bytes written, or a negative value on error. Note that this writes bytes not chars, these can be anything, even '\0' A kernel level write should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td></td></tr>
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ssize_t </dd></dl>

</div>
</div>
<a id="a1db57eb907f680ab844066357b793d5f" name="a1db57eb907f680ab844066357b793d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db57eb907f680ab844066357b793d5f">&#9670;&#160;</a></span>s_write_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_write_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9df1ce5034a7614c2c55bc05500f5991">log_message_t</a></td>          <td class="paramname"><span class="paramname"><em>logtype</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *</td>          <td class="paramname"><span class="paramname"><em>proc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>old_nice</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc68daae1d550a0993e99d583b0c1264" name="abc68daae1d550a0993e99d583b0c1264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc68daae1d550a0993e99d583b0c1264">&#9670;&#160;</a></span>s_zombie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void s_zombie </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
