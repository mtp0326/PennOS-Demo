<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PennOS: src/util/sys_call.c File Reference</title>
<link rel="icon" href="../../icons8-document-50.png" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">PennOS<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">PennOS, a UNIX-like operating system.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="../../dir_b7878ad5ecbf2506f4125b9d34c97e45.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sys_call.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="../../db/d80/sys__call_8h_source.html">sys_call.h</a>&quot;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &quot;stdio.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a628a3b2c1d461572974e97bea327519d" id="r_a628a3b2c1d461572974e97bea327519d"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a628a3b2c1d461572974e97bea327519d">duplicate_argv</a> (char *argv[])</td></tr>
<tr class="separator:a628a3b2c1d461572974e97bea327519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d16eae921a526aeb277c961c6933fc" id="r_a33d16eae921a526aeb277c961c6933fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33d16eae921a526aeb277c961c6933fc">free_argv</a> (char *argv[])</td></tr>
<tr class="separator:a33d16eae921a526aeb277c961c6933fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b789c710ba1501bcd8cf54e4382e50" id="r_a43b789c710ba1501bcd8cf54e4382e50"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43b789c710ba1501bcd8cf54e4382e50">s_spawn</a> (void *(*func)(void *), char *argv[], int fd0, int fd1)</td></tr>
<tr class="memdesc:a43b789c710ba1501bcd8cf54e4382e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a child process that executes the function <code>func</code>. The child will retain some attributes of the parent.  <br /></td></tr>
<tr class="separator:a43b789c710ba1501bcd8cf54e4382e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b97025761b7f8ad7e59b641cad08d6" id="r_a62b97025761b7f8ad7e59b641cad08d6"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62b97025761b7f8ad7e59b641cad08d6">s_spawn_nice</a> (void *(*func)(void *), char *argv[], int fd0, int fd1, unsigned int <a class="el" href="../../d8/d75/pennos_8c.html#a2e0cca4a43c21259b881d59c96c74fe0">priority</a>)</td></tr>
<tr class="separator:a62b97025761b7f8ad7e59b641cad08d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0c6c4ae69799354d707ff57ac925d3" id="r_a3c0c6c4ae69799354d707ff57ac925d3"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c0c6c4ae69799354d707ff57ac925d3">s_waitpid</a> (pid_t pid, int *wstatus, bool nohang)</td></tr>
<tr class="memdesc:a3c0c6c4ae69799354d707ff57ac925d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a child of the calling process, until it changes state. If <code>nohang</code> is true, this will not block the calling process and return immediately.  <br /></td></tr>
<tr class="separator:a3c0c6c4ae69799354d707ff57ac925d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e6794b108eea25459bd7fe31de4e76" id="r_a18e6794b108eea25459bd7fe31de4e76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18e6794b108eea25459bd7fe31de4e76">s_kill</a> (pid_t pid, int signal)</td></tr>
<tr class="memdesc:a18e6794b108eea25459bd7fe31de4e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to a particular process.  <br /></td></tr>
<tr class="separator:a18e6794b108eea25459bd7fe31de4e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c8865d5bf1ca946e5b5405190f6690" id="r_a53c8865d5bf1ca946e5b5405190f6690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53c8865d5bf1ca946e5b5405190f6690">s_exit</a> (void)</td></tr>
<tr class="memdesc:a53c8865d5bf1ca946e5b5405190f6690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally exit the calling process.  <br /></td></tr>
<tr class="separator:a53c8865d5bf1ca946e5b5405190f6690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac711d33fcf2573a590b224b6debab996" id="r_ac711d33fcf2573a590b224b6debab996"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac711d33fcf2573a590b224b6debab996">s_nice</a> (pid_t pid, int <a class="el" href="../../d8/d75/pennos_8c.html#a2e0cca4a43c21259b881d59c96c74fe0">priority</a>)</td></tr>
<tr class="memdesc:ac711d33fcf2573a590b224b6debab996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of the specified thread.  <br /></td></tr>
<tr class="separator:ac711d33fcf2573a590b224b6debab996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec37528a3c7935864924764d1911126c" id="r_aec37528a3c7935864924764d1911126c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec37528a3c7935864924764d1911126c">s_sleep</a> (unsigned int ticks)</td></tr>
<tr class="memdesc:aec37528a3c7935864924764d1911126c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends execution of the calling proces for a specified number of clock ticks.  <br /></td></tr>
<tr class="separator:aec37528a3c7935864924764d1911126c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9116ac84aeec3a4717eab9aa7137080e" id="r_a9116ac84aeec3a4717eab9aa7137080e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9116ac84aeec3a4717eab9aa7137080e">s_spawn_and_wait</a> (void *(*func)(void *), char *argv[], int fd0, int fd1, bool nohang, unsigned int <a class="el" href="../../d8/d75/pennos_8c.html#a2e0cca4a43c21259b881d59c96c74fe0">priority</a>)</td></tr>
<tr class="memdesc:a9116ac84aeec3a4717eab9aa7137080e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns and waits for a process.  <br /></td></tr>
<tr class="separator:a9116ac84aeec3a4717eab9aa7137080e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ff16131dec7dc8b25686329a19d0db" id="r_a35ff16131dec7dc8b25686329a19d0db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35ff16131dec7dc8b25686329a19d0db">s_find_process</a> (pid_t pid)</td></tr>
<tr class="memdesc:a35ff16131dec7dc8b25686329a19d0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a process in any state.  <br /></td></tr>
<tr class="separator:a35ff16131dec7dc8b25686329a19d0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ef4dc77a6071976f7d93759d48afa6" id="r_a09ef4dc77a6071976f7d93759d48afa6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09ef4dc77a6071976f7d93759d48afa6">s_remove_process</a> (pid_t pid)</td></tr>
<tr class="memdesc:a09ef4dc77a6071976f7d93759d48afa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a process in any state.  <br /></td></tr>
<tr class="separator:a09ef4dc77a6071976f7d93759d48afa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5efee98239591e685e3ae7da8203b21" id="r_ab5efee98239591e685e3ae7da8203b21"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5efee98239591e685e3ae7da8203b21">s_function_from_string</a> (char *program)</td></tr>
<tr class="separator:ab5efee98239591e685e3ae7da8203b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db57eb907f680ab844066357b793d5f" id="r_a1db57eb907f680ab844066357b793d5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1db57eb907f680ab844066357b793d5f">s_write_log</a> (<a class="el" href="../../db/d80/sys__call_8h.html#a9df1ce5034a7614c2c55bc05500f5991">log_message_t</a> logtype, <a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *proc, unsigned int old_nice)</td></tr>
<tr class="separator:a1db57eb907f680ab844066357b793d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc95330d937650d14281e3d6041f284" id="r_a7cc95330d937650d14281e3d6041f284"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cc95330d937650d14281e3d6041f284">s_move_process</a> (<a class="el" href="../../de/d82/structCircularList.html">CircularList</a> *destination, pid_t pid)</td></tr>
<tr class="separator:a7cc95330d937650d14281e3d6041f284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<<<<<<< HEAD
=======
<tr class="memitem:afec6e61720e05918efefeab347e950f3" id="r_afec6e61720e05918efefeab347e950f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afec6e61720e05918efefeab347e950f3">s_open</a> (const char *fname, int mode)</td></tr>
<tr class="memdesc:afec6e61720e05918efefeab347e950f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">open a file name fname with the mode mode and return a file descriptor. The allowed modes are as follows:  <br /></td></tr>
<tr class="separator:afec6e61720e05918efefeab347e950f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcf52e63af8002a5d7c02774ee0578f" id="r_afdcf52e63af8002a5d7c02774ee0578f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdcf52e63af8002a5d7c02774ee0578f">s_read</a> (int fd, int n, char *buf)</td></tr>
<tr class="memdesc:afdcf52e63af8002a5d7c02774ee0578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">read n bytes from the file referenced by fd. On return, s_read returns the number of bytes read, 0 if EOF is reached, or a negative number on error. A kernel level read should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes.  <br /></td></tr>
<tr class="separator:afdcf52e63af8002a5d7c02774ee0578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3317435b4bd7309160538fc5d730eb9" id="r_ad3317435b4bd7309160538fc5d730eb9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3317435b4bd7309160538fc5d730eb9">s_write</a> (int fd, const char *str, int n)</td></tr>
<tr class="memdesc:ad3317435b4bd7309160538fc5d730eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">write n bytes of the string referenced by str to the file fd and increment the file pointer by n. On return, s_write returns the number of bytes written, or a negative value on error. Note that this writes bytes not chars, these can be anything, even '\0' A kernel level write should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes.  <br /></td></tr>
<tr class="separator:ad3317435b4bd7309160538fc5d730eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee856dbd0706f79a440d1e98b42d32d" id="r_a1ee856dbd0706f79a440d1e98b42d32d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ee856dbd0706f79a440d1e98b42d32d">s_close</a> (int fd)</td></tr>
<tr class="memdesc:a1ee856dbd0706f79a440d1e98b42d32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">close the file fd and return 0 on success, or a negative value on failure. A kernel level close should occur, and on success the local process’ file descriptor table should be cleaned up appropriately.  <br /></td></tr>
<tr class="separator:a1ee856dbd0706f79a440d1e98b42d32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395873f1de0b89a686d438580ba5dcf7" id="r_a395873f1de0b89a686d438580ba5dcf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a395873f1de0b89a686d438580ba5dcf7">s_unlink</a> (const char *fname)</td></tr>
<tr class="separator:a395873f1de0b89a686d438580ba5dcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21f611f4fb486935d9ad2915a529d3b" id="r_ac21f611f4fb486935d9ad2915a529d3b"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac21f611f4fb486935d9ad2915a529d3b">s_lseek</a> (int fd, int offset, int whence)</td></tr>
<tr class="memdesc:ac21f611f4fb486935d9ad2915a529d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">reposition the file pointer for fd to the offset relative to whence. You must also implement the constants F_SEEK_SET, F_SEEK_CUR, and F_SEEK_END, which reference similar file whences as their similarly named counterparts in lseek(2). A kernel level lseek should occur, and necessary changes to the calling process’ file descriptor table will be necessary.  <br /></td></tr>
<tr class="separator:ac21f611f4fb486935d9ad2915a529d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab913114f1534d9ab098d0d5c4517bfe2" id="r_ab913114f1534d9ab098d0d5c4517bfe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab913114f1534d9ab098d0d5c4517bfe2">s_ls</a> (const char *filename)</td></tr>
<tr class="memdesc:ab913114f1534d9ab098d0d5c4517bfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the file filename in the current directory. If filename is NULL, list all files in the current directory. Before EC implementations, this should be very simple and could literally be a call a similar k_function.  <br /></td></tr>
<tr class="separator:ab913114f1534d9ab098d0d5c4517bfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
>>>>>>> main
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a628a3b2c1d461572974e97bea327519d" name="a628a3b2c1d461572974e97bea327519d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628a3b2c1d461572974e97bea327519d">&#9670;&#160;</a></span>duplicate_argv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** duplicate_argv </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em>[]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33d16eae921a526aeb277c961c6933fc" name="a33d16eae921a526aeb277c961c6933fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d16eae921a526aeb277c961c6933fc">&#9670;&#160;</a></span>free_argv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_argv </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em>[]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ee856dbd0706f79a440d1e98b42d32d" name="a1ee856dbd0706f79a440d1e98b42d32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee856dbd0706f79a440d1e98b42d32d">&#9670;&#160;</a></span>s_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_close </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>close the file fd and return 0 on success, or a negative value on failure. A kernel level close should occur, and on success the local process’ file descriptor table should be cleaned up appropriately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a53c8865d5bf1ca946e5b5405190f6690" name="a53c8865d5bf1ca946e5b5405190f6690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c8865d5bf1ca946e5b5405190f6690">&#9670;&#160;</a></span>s_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void s_exit </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally exit the calling process. </p>

</div>
</div>
<a id="a35ff16131dec7dc8b25686329a19d0db" name="a35ff16131dec7dc8b25686329a19d0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ff16131dec7dc8b25686329a19d0db">&#9670;&#160;</a></span>s_find_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> * s_find_process </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a process in any state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcb_t* </dd></dl>

</div>
</div>
<a id="ab5efee98239591e685e3ae7da8203b21" name="ab5efee98239591e685e3ae7da8203b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5efee98239591e685e3ae7da8203b21">&#9670;&#160;</a></span>s_function_from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * s_function_from_string </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>program</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18e6794b108eea25459bd7fe31de4e76" name="a18e6794b108eea25459bd7fe31de4e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e6794b108eea25459bd7fe31de4e76">&#9670;&#160;</a></span>s_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_kill </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>signal</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a signal to a particular process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Process ID of the target proces. </td></tr>
    <tr><td class="paramname">signal</td><td>Signal number to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<<<<<<< HEAD
=======
<a id="ab913114f1534d9ab098d0d5c4517bfe2" name="ab913114f1534d9ab098d0d5c4517bfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab913114f1534d9ab098d0d5c4517bfe2">&#9670;&#160;</a></span>s_ls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void s_ls </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List the file filename in the current directory. If filename is NULL, list all files in the current directory. Before EC implementations, this should be very simple and could literally be a call a similar k_function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac21f611f4fb486935d9ad2915a529d3b" name="ac21f611f4fb486935d9ad2915a529d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21f611f4fb486935d9ad2915a529d3b">&#9670;&#160;</a></span>s_lseek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">off_t s_lseek </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>whence</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reposition the file pointer for fd to the offset relative to whence. You must also implement the constants F_SEEK_SET, F_SEEK_CUR, and F_SEEK_END, which reference similar file whences as their similarly named counterparts in lseek(2). A kernel level lseek should occur, and necessary changes to the calling process’ file descriptor table will be necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td></td></tr>
    <tr><td class="paramname">offset</td><td></td></tr>
    <tr><td class="paramname">whence</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
>>>>>>> main
<a id="a7cc95330d937650d14281e3d6041f284" name="a7cc95330d937650d14281e3d6041f284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc95330d937650d14281e3d6041f284">&#9670;&#160;</a></span>s_move_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_move_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d82/structCircularList.html">CircularList</a> *</td>          <td class="paramname"><span class="paramname"><em>destination</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac711d33fcf2573a590b224b6debab996" name="ac711d33fcf2573a590b224b6debab996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac711d33fcf2573a590b224b6debab996">&#9670;&#160;</a></span>s_nice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_nice </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Process ID of the target thread. </td></tr>
    <tr><td class="paramname">priority</td><td>The new priorty value of the thread (0, 1, or 2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<<<<<<< HEAD
=======
<a id="afec6e61720e05918efefeab347e950f3" name="afec6e61720e05918efefeab347e950f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec6e61720e05918efefeab347e950f3">&#9670;&#160;</a></span>s_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_open </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>open a file name fname with the mode mode and return a file descriptor. The allowed modes are as follows: </p>
<p>F_WRITE - writing and reading, truncates if the file exists, or creates it if it does not exist. Only one instance of a file can be opened in F_WRITE mode; error if PennOS attempts to open a file in F_WRITE mode more than once F_READ - open the file for reading only, return an error if the file does not exist F_APPEND - open the file for reading and writing but does not truncate the file if exists; additionally, the file pointer references the end of the file.</p>
<p>s_open returns a file descriptor on success and a negative value on error. This open will initially be done at the kernel level, using a more intricate and already-implemented kernel level function. If the kernel level function succeeds and returns a fd, the user level function should also somehow keep track that such file descriptor is managed by the calling process. This can be done in multiple ways.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td></td></tr>
    <tr><td class="paramname">mode</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="afdcf52e63af8002a5d7c02774ee0578f" name="afdcf52e63af8002a5d7c02774ee0578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcf52e63af8002a5d7c02774ee0578f">&#9670;&#160;</a></span>s_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t s_read </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read n bytes from the file referenced by fd. On return, s_read returns the number of bytes read, 0 if EOF is reached, or a negative number on error. A kernel level read should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ssize_t </dd></dl>

</div>
</div>
>>>>>>> main
<a id="a09ef4dc77a6071976f7d93759d48afa6" name="a09ef4dc77a6071976f7d93759d48afa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ef4dc77a6071976f7d93759d48afa6">&#9670;&#160;</a></span>s_remove_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_remove_process </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a process in any state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="aec37528a3c7935864924764d1911126c" name="aec37528a3c7935864924764d1911126c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec37528a3c7935864924764d1911126c">&#9670;&#160;</a></span>s_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void s_sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>ticks</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspends execution of the calling proces for a specified number of clock ticks. </p>
<p>This function is analogous to <code>sleep(3)</code> in Linux, with the behavior that the system clock continues to tick even if the call is interrupted. The sleep can be interrupted by a P_SIGTERM signal, after which the function will return prematurely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticks</td><td>Duration of the sleep in system clock ticks. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43b789c710ba1501bcd8cf54e4382e50" name="a43b789c710ba1501bcd8cf54e4382e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b789c710ba1501bcd8cf54e4382e50">&#9670;&#160;</a></span>s_spawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t s_spawn </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *)</td>          <td class="paramname"><span class="paramname"><em>func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a child process that executes the function <code>func</code>. The child will retain some attributes of the parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to be executed by the child process. </td></tr>
    <tr><td class="paramname">argv</td><td>Null-terminated array of args, including the command name as argv[0]. </td></tr>
    <tr><td class="paramname">fd0</td><td>Input file descriptor. </td></tr>
    <tr><td class="paramname">fd1</td><td>Output file descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pid_t The process ID of the created child process. // need to define error output? </dd></dl>

</div>
</div>
<a id="a9116ac84aeec3a4717eab9aa7137080e" name="a9116ac84aeec3a4717eab9aa7137080e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9116ac84aeec3a4717eab9aa7137080e">&#9670;&#160;</a></span>s_spawn_and_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_spawn_and_wait </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *)</td>          <td class="paramname"><span class="paramname"><em>func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nohang</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns and waits for a process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td></td></tr>
    <tr><td class="paramname">argv</td><td></td></tr>
    <tr><td class="paramname">fd0</td><td></td></tr>
    <tr><td class="paramname">fd1</td><td></td></tr>
    <tr><td class="paramname">nohang</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a62b97025761b7f8ad7e59b641cad08d6" name="a62b97025761b7f8ad7e59b641cad08d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b97025761b7f8ad7e59b641cad08d6">&#9670;&#160;</a></span>s_spawn_nice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t s_spawn_nice </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *)</td>          <td class="paramname"><span class="paramname"><em>func</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a395873f1de0b89a686d438580ba5dcf7" name="a395873f1de0b89a686d438580ba5dcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395873f1de0b89a686d438580ba5dcf7">&#9670;&#160;</a></span>s_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_unlink </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a3c0c6c4ae69799354d707ff57ac925d3" name="a3c0c6c4ae69799354d707ff57ac925d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0c6c4ae69799354d707ff57ac925d3">&#9670;&#160;</a></span>s_waitpid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t s_waitpid </td>
          <td>(</td>
          <td class="paramtype">pid_t</td>          <td class="paramname"><span class="paramname"><em>pid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>wstatus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nohang</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a child of the calling process, until it changes state. If <code>nohang</code> is true, this will not block the calling process and return immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Process ID of the child to wait for. </td></tr>
    <tr><td class="paramname">wstatus</td><td>Pointer to an integer variable where the status will be stored. </td></tr>
    <tr><td class="paramname">nohang</td><td>If true, return immediately if no child has exited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pid_t The process ID of the child which has changed state on success, -1 on error. </dd></dl>

</div>
</div>
<<<<<<< HEAD
=======
<a id="ad3317435b4bd7309160538fc5d730eb9" name="ad3317435b4bd7309160538fc5d730eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3317435b4bd7309160538fc5d730eb9">&#9670;&#160;</a></span>s_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t s_write </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write n bytes of the string referenced by str to the file fd and increment the file pointer by n. On return, s_write returns the number of bytes written, or a negative value on error. Note that this writes bytes not chars, these can be anything, even '\0' A kernel level write should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td></td></tr>
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ssize_t </dd></dl>

</div>
</div>
>>>>>>> main
<a id="a1db57eb907f680ab844066357b793d5f" name="a1db57eb907f680ab844066357b793d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db57eb907f680ab844066357b793d5f">&#9670;&#160;</a></span>s_write_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int s_write_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d80/sys__call_8h.html#a9df1ce5034a7614c2c55bc05500f5991">log_message_t</a></td>          <td class="paramname"><span class="paramname"><em>logtype</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d5f/structpcb__t.html">pcb_t</a> *</td>          <td class="paramname"><span class="paramname"><em>proc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>old_nice</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
