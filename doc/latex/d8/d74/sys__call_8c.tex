\doxysection{src/util/sys\+\_\+call.c File Reference}
\hypertarget{sys__call_8c}{}\label{sys__call_8c}\index{src/util/sys\_call.c@{src/util/sys\_call.c}}
{\ttfamily \#include "{}sys\+\_\+call.\+h"{}}\newline
{\ttfamily \#include "{}stdio.\+h"{}}\newline
{\ttfamily \#include $<$unistd.\+h$>$}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
char \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{sys__call_8c_a628a3b2c1d461572974e97bea327519d}{duplicate\+\_\+argv}} (char \texorpdfstring{$\ast$}{*}argv\mbox{[}$\,$\mbox{]})
\item 
void \mbox{\hyperlink{sys__call_8c_a33d16eae921a526aeb277c961c6933fc}{free\+\_\+argv}} (char \texorpdfstring{$\ast$}{*}argv\mbox{[}$\,$\mbox{]})
\item 
pid\+\_\+t \mbox{\hyperlink{sys__call_8c_a43b789c710ba1501bcd8cf54e4382e50}{s\+\_\+spawn}} (void \texorpdfstring{$\ast$}{*}(\texorpdfstring{$\ast$}{*}func)(void \texorpdfstring{$\ast$}{*}), char \texorpdfstring{$\ast$}{*}argv\mbox{[}$\,$\mbox{]}, int fd0, int fd1)
\begin{DoxyCompactList}\small\item\em Create a child process that executes the function {\ttfamily func}. The child will retain some attributes of the parent. \end{DoxyCompactList}\item 
pid\+\_\+t \mbox{\hyperlink{sys__call_8c_a62b97025761b7f8ad7e59b641cad08d6}{s\+\_\+spawn\+\_\+nice}} (void \texorpdfstring{$\ast$}{*}(\texorpdfstring{$\ast$}{*}func)(void \texorpdfstring{$\ast$}{*}), char \texorpdfstring{$\ast$}{*}argv\mbox{[}$\,$\mbox{]}, int fd0, int fd1, unsigned int \mbox{\hyperlink{pennos_8c_a2e0cca4a43c21259b881d59c96c74fe0}{priority}})
\begin{DoxyCompactList}\small\item\em Create a child process that executes the function {\ttfamily func}, with a specified priority. This is an exact copy of \doxylink{sys__call_8c_a43b789c710ba1501bcd8cf54e4382e50}{s\+\_\+spawn} except that the priority of the created process can be specificed at creation. \end{DoxyCompactList}\item 
pid\+\_\+t \mbox{\hyperlink{sys__call_8c_a3c0c6c4ae69799354d707ff57ac925d3}{s\+\_\+waitpid}} (pid\+\_\+t pid, int \texorpdfstring{$\ast$}{*}wstatus, bool \mbox{\hyperlink{stress_8c_aaacb1f06dd4ec309398fb76d008fdc90}{nohang}})
\begin{DoxyCompactList}\small\item\em Wait on a child of the calling process, until it changes state. If {\ttfamily nohang} is true, this will not block the calling process and return immediately. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{sys__call_8c_a18e6794b108eea25459bd7fe31de4e76}{s\+\_\+kill}} (pid\+\_\+t pid, int signal)
\begin{DoxyCompactList}\small\item\em Send a signal to a particular process. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__call_8c_a964c6f7d6a06dddfd15cbd2d348dbd59}{s\+\_\+reap\+\_\+all\+\_\+child}} (\mbox{\hyperlink{structpcb__t}{pcb\+\_\+t}} \texorpdfstring{$\ast$}{*}parent)
\begin{DoxyCompactList}\small\item\em Uses recursion to reap all children of specified parent. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__call_8c_a53c8865d5bf1ca946e5b5405190f6690}{s\+\_\+exit}} (void)
\begin{DoxyCompactList}\small\item\em Unconditionally exit the calling process. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__call_8c_abc68daae1d550a0993e99d583b0c1264}{s\+\_\+zombie}} (pid\+\_\+t pid)
\item 
int \mbox{\hyperlink{sys__call_8c_ac711d33fcf2573a590b224b6debab996}{s\+\_\+nice}} (pid\+\_\+t pid, int \mbox{\hyperlink{pennos_8c_a2e0cca4a43c21259b881d59c96c74fe0}{priority}})
\begin{DoxyCompactList}\small\item\em Set the priority of the specified thread. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{sys__call_8c_a0b8fdff50e5b9c5fa8559fe294e4243f}{s\+\_\+sleep}} (unsigned int ticks)
\begin{DoxyCompactList}\small\item\em Suspends execution of the calling proces for a specified number of clock ticks. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{sys__call_8c_a1a3aeae7e3fb489c4cf3c4dc3911bbce}{s\+\_\+busy}} (void)
\begin{DoxyCompactList}\small\item\em Suspends execution of the calling process for an unspecified amount of time. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{sys__call_8c_a9116ac84aeec3a4717eab9aa7137080e}{s\+\_\+spawn\+\_\+and\+\_\+wait}} (void \texorpdfstring{$\ast$}{*}(\texorpdfstring{$\ast$}{*}func)(void \texorpdfstring{$\ast$}{*}), char \texorpdfstring{$\ast$}{*}argv\mbox{[}$\,$\mbox{]}, int fd0, int fd1, bool \mbox{\hyperlink{stress_8c_aaacb1f06dd4ec309398fb76d008fdc90}{nohang}}, unsigned int \mbox{\hyperlink{pennos_8c_a2e0cca4a43c21259b881d59c96c74fe0}{priority}})
\begin{DoxyCompactList}\small\item\em Spawns and waits for a process. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{sys__call_8c_a31e11484cfd56821c3e9a1fa43aafcf0}{s\+\_\+fg}} (\mbox{\hyperlink{structpcb__t}{pcb\+\_\+t}} \texorpdfstring{$\ast$}{*}proc)
\item 
int \mbox{\hyperlink{sys__call_8c_a3dd0bc17589ba38590b19d8256ffee4f}{s\+\_\+bg\+\_\+wait}} (\mbox{\hyperlink{structpcb__t}{pcb\+\_\+t}} \texorpdfstring{$\ast$}{*}proc)
\begin{DoxyCompactList}\small\item\em Checks status of background processes with waitpid(nohang) \end{DoxyCompactList}\item 
\mbox{\hyperlink{structpcb__t}{pcb\+\_\+t}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{sys__call_8c_a35ff16131dec7dc8b25686329a19d0db}{s\+\_\+find\+\_\+process}} (pid\+\_\+t pid)
\begin{DoxyCompactList}\small\item\em Finds a process in any state. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{sys__call_8c_a09ef4dc77a6071976f7d93759d48afa6}{s\+\_\+remove\+\_\+process}} (pid\+\_\+t pid)
\begin{DoxyCompactList}\small\item\em Removes a process in any state. \end{DoxyCompactList}\item 
void \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{sys__call_8c_ab5efee98239591e685e3ae7da8203b21}{s\+\_\+function\+\_\+from\+\_\+string}} (char \texorpdfstring{$\ast$}{*}program)
\item 
int \mbox{\hyperlink{sys__call_8c_a1db57eb907f680ab844066357b793d5f}{s\+\_\+write\+\_\+log}} (\mbox{\hyperlink{sys__call_8h_a9df1ce5034a7614c2c55bc05500f5991}{log\+\_\+message\+\_\+t}} logtype, \mbox{\hyperlink{structpcb__t}{pcb\+\_\+t}} \texorpdfstring{$\ast$}{*}proc, unsigned int old\+\_\+nice)
\item 
int \mbox{\hyperlink{sys__call_8c_a7cc95330d937650d14281e3d6041f284}{s\+\_\+move\+\_\+process}} (\mbox{\hyperlink{structCircularList}{Circular\+List}} \texorpdfstring{$\ast$}{*}destination, pid\+\_\+t pid)
\item 
int \mbox{\hyperlink{sys__call_8c_a2e87f593f5c2f59d7a90958b3e51751d}{s\+\_\+print\+\_\+process}} (\mbox{\hyperlink{structCircularList}{Circular\+List}} \texorpdfstring{$\ast$}{*}list)
\item 
int \mbox{\hyperlink{sys__call_8c_a4e0c2e47d0948979e7be9350582158c8}{s\+\_\+print\+\_\+jobs}} (\mbox{\hyperlink{structCircularList}{Circular\+List}} \texorpdfstring{$\ast$}{*}list)
\item 
int \mbox{\hyperlink{sys__call_8c_afec6e61720e05918efefeab347e950f3}{s\+\_\+open}} (const char \texorpdfstring{$\ast$}{*}fname, int mode)
\begin{DoxyCompactList}\small\item\em open a file name fname with the mode mode and return a file descriptor. The allowed modes are as follows\+: \end{DoxyCompactList}\item 
ssize\+\_\+t \mbox{\hyperlink{sys__call_8c_afdcf52e63af8002a5d7c02774ee0578f}{s\+\_\+read}} (int fd, int n, char \texorpdfstring{$\ast$}{*}buf)
\begin{DoxyCompactList}\small\item\em read n bytes from the file referenced by fd. On return, s\+\_\+read returns the number of bytes read, 0 if EOF is reached, or a negative number on error. A kernel level read should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes. \end{DoxyCompactList}\item 
ssize\+\_\+t \mbox{\hyperlink{sys__call_8c_ad3317435b4bd7309160538fc5d730eb9}{s\+\_\+write}} (int fd, const char \texorpdfstring{$\ast$}{*}str, int n)
\begin{DoxyCompactList}\small\item\em write n bytes of the string referenced by str to the file fd and increment the file pointer by n. On return, s\+\_\+write returns the number of bytes written, or a negative value on error. Note that this writes bytes not chars, these can be anything, even \textquotesingle{}\textbackslash{}0\textquotesingle{} A kernel level write should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{sys__call_8c_a1ee856dbd0706f79a440d1e98b42d32d}{s\+\_\+close}} (int fd)
\begin{DoxyCompactList}\small\item\em close the file fd and return 0 on success, or a negative value on failure. A kernel level close should occur, and on success the local process’ file descriptor table should be cleaned up appropriately. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{sys__call_8c_a395873f1de0b89a686d438580ba5dcf7}{s\+\_\+unlink}} (const char \texorpdfstring{$\ast$}{*}fname)
\item 
off\+\_\+t \mbox{\hyperlink{sys__call_8c_ac21f611f4fb486935d9ad2915a529d3b}{s\+\_\+lseek}} (int fd, int offset, int whence)
\begin{DoxyCompactList}\small\item\em reposition the file pointer for fd to the offset relative to whence. You must also implement the constants F\+\_\+\+SEEK\+\_\+\+SET, F\+\_\+\+SEEK\+\_\+\+CUR, and F\+\_\+\+SEEK\+\_\+\+END, which reference similar file whences as their similarly named counterparts in lseek(2). A kernel level lseek should occur, and necessary changes to the calling process’ file descriptor table will be necessary. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__call_8c_ae166ac7970869bda5550149e8771c3af}{s\+\_\+ls}} (const char \texorpdfstring{$\ast$}{*}filename, int fd)
\begin{DoxyCompactList}\small\item\em List the file filename in the current directory. If filename is NULL, list all files in the current directory. Before EC implementations, this should be very simple and could literally be a call a similar k\+\_\+function. \end{DoxyCompactList}\item 
char \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{sys__call_8c_a18b25be5ab040f60070ff9ea839648be}{s\+\_\+read\+\_\+all}} (const char \texorpdfstring{$\ast$}{*}filename, int \texorpdfstring{$\ast$}{*}read\+\_\+num)
\item 
char \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{sys__call_8c_a2638b24106c052e0a513643f712e8d00}{s\+\_\+get\+\_\+fname\+\_\+from\+\_\+fd}} (int fd)
\item 
int \mbox{\hyperlink{sys__call_8c_ab40c873ca412b774e2fc1b59527538be}{s\+\_\+update\+\_\+timestamp}} (const char \texorpdfstring{$\ast$}{*}source)
\item 
off\+\_\+t \mbox{\hyperlink{sys__call_8c_ae8b8546b3350e1602c1574b1b0cb58d0}{s\+\_\+does\+\_\+file\+\_\+exist2}} (const char \texorpdfstring{$\ast$}{*}fname)
\item 
int \mbox{\hyperlink{sys__call_8c_aeea2dcf94b9a35c86a67cf6ec97fd21d}{s\+\_\+rename}} (const char \texorpdfstring{$\ast$}{*}source, const char \texorpdfstring{$\ast$}{*}dest)
\item 
int \mbox{\hyperlink{sys__call_8c_a92d71eb90d0b9786bec0302347f5a99f}{s\+\_\+change\+\_\+mode}} (const char \texorpdfstring{$\ast$}{*}change, const char \texorpdfstring{$\ast$}{*}filename)
\item 
int \mbox{\hyperlink{sys__call_8c_ad55b8ad7785acad109a35a819e415622}{s\+\_\+cp\+\_\+within\+\_\+fat}} (char \texorpdfstring{$\ast$}{*}source, char \texorpdfstring{$\ast$}{*}dest)
\item 
int \mbox{\hyperlink{sys__call_8c_a494917a8ce36ad19470a2116e57a1bc3}{s\+\_\+cp\+\_\+to\+\_\+host}} (char \texorpdfstring{$\ast$}{*}source, char \texorpdfstring{$\ast$}{*}host\+\_\+dest)
\item 
int \mbox{\hyperlink{sys__call_8c_a1e2fd1371e1cd60d964afd80eb89943e}{s\+\_\+cp\+\_\+from\+\_\+host}} (char \texorpdfstring{$\ast$}{*}host\+\_\+source, char \texorpdfstring{$\ast$}{*}dest)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{sys__call_8c_a628a3b2c1d461572974e97bea327519d}\label{sys__call_8c_a628a3b2c1d461572974e97bea327519d} 
\index{sys\_call.c@{sys\_call.c}!duplicate\_argv@{duplicate\_argv}}
\index{duplicate\_argv@{duplicate\_argv}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{duplicate\_argv()}{duplicate\_argv()}}
{\footnotesize\ttfamily char \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} duplicate\+\_\+argv (\begin{DoxyParamCaption}\item[{char \texorpdfstring{$\ast$}{*}}]{argv\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a33d16eae921a526aeb277c961c6933fc}\label{sys__call_8c_a33d16eae921a526aeb277c961c6933fc} 
\index{sys\_call.c@{sys\_call.c}!free\_argv@{free\_argv}}
\index{free\_argv@{free\_argv}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{free\_argv()}{free\_argv()}}
{\footnotesize\ttfamily void free\+\_\+argv (\begin{DoxyParamCaption}\item[{char \texorpdfstring{$\ast$}{*}}]{argv\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a3dd0bc17589ba38590b19d8256ffee4f}\label{sys__call_8c_a3dd0bc17589ba38590b19d8256ffee4f} 
\index{sys\_call.c@{sys\_call.c}!s\_bg\_wait@{s\_bg\_wait}}
\index{s\_bg\_wait@{s\_bg\_wait}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_bg\_wait()}{s\_bg\_wait()}}
{\footnotesize\ttfamily int s\+\_\+bg\+\_\+wait (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpcb__t}{pcb\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{proc }\end{DoxyParamCaption})}



Checks status of background processes with waitpid(nohang) 


\begin{DoxyParams}{Parameters}
{\em proc} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_a1a3aeae7e3fb489c4cf3c4dc3911bbce}\label{sys__call_8c_a1a3aeae7e3fb489c4cf3c4dc3911bbce} 
\index{sys\_call.c@{sys\_call.c}!s\_busy@{s\_busy}}
\index{s\_busy@{s\_busy}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_busy()}{s\_busy()}}
{\footnotesize\ttfamily int s\+\_\+busy (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Suspends execution of the calling process for an unspecified amount of time. 


\begin{DoxyParams}{Parameters}
{\em void.} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int Returns 0 on success, -\/1 on failure and sets errno. 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_a92d71eb90d0b9786bec0302347f5a99f}\label{sys__call_8c_a92d71eb90d0b9786bec0302347f5a99f} 
\index{sys\_call.c@{sys\_call.c}!s\_change\_mode@{s\_change\_mode}}
\index{s\_change\_mode@{s\_change\_mode}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_change\_mode()}{s\_change\_mode()}}
{\footnotesize\ttfamily int s\+\_\+change\+\_\+mode (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{change,  }\item[{const char \texorpdfstring{$\ast$}{*}}]{filename }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a1ee856dbd0706f79a440d1e98b42d32d}\label{sys__call_8c_a1ee856dbd0706f79a440d1e98b42d32d} 
\index{sys\_call.c@{sys\_call.c}!s\_close@{s\_close}}
\index{s\_close@{s\_close}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_close()}{s\_close()}}
{\footnotesize\ttfamily int s\+\_\+close (\begin{DoxyParamCaption}\item[{int}]{fd }\end{DoxyParamCaption})}



close the file fd and return 0 on success, or a negative value on failure. A kernel level close should occur, and on success the local process’ file descriptor table should be cleaned up appropriately. 


\begin{DoxyParams}{Parameters}
{\em fd} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_a1e2fd1371e1cd60d964afd80eb89943e}\label{sys__call_8c_a1e2fd1371e1cd60d964afd80eb89943e} 
\index{sys\_call.c@{sys\_call.c}!s\_cp\_from\_host@{s\_cp\_from\_host}}
\index{s\_cp\_from\_host@{s\_cp\_from\_host}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_cp\_from\_host()}{s\_cp\_from\_host()}}
{\footnotesize\ttfamily int s\+\_\+cp\+\_\+from\+\_\+host (\begin{DoxyParamCaption}\item[{char \texorpdfstring{$\ast$}{*}}]{host\+\_\+source,  }\item[{char \texorpdfstring{$\ast$}{*}}]{dest }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a494917a8ce36ad19470a2116e57a1bc3}\label{sys__call_8c_a494917a8ce36ad19470a2116e57a1bc3} 
\index{sys\_call.c@{sys\_call.c}!s\_cp\_to\_host@{s\_cp\_to\_host}}
\index{s\_cp\_to\_host@{s\_cp\_to\_host}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_cp\_to\_host()}{s\_cp\_to\_host()}}
{\footnotesize\ttfamily int s\+\_\+cp\+\_\+to\+\_\+host (\begin{DoxyParamCaption}\item[{char \texorpdfstring{$\ast$}{*}}]{source,  }\item[{char \texorpdfstring{$\ast$}{*}}]{host\+\_\+dest }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_ad55b8ad7785acad109a35a819e415622}\label{sys__call_8c_ad55b8ad7785acad109a35a819e415622} 
\index{sys\_call.c@{sys\_call.c}!s\_cp\_within\_fat@{s\_cp\_within\_fat}}
\index{s\_cp\_within\_fat@{s\_cp\_within\_fat}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_cp\_within\_fat()}{s\_cp\_within\_fat()}}
{\footnotesize\ttfamily int s\+\_\+cp\+\_\+within\+\_\+fat (\begin{DoxyParamCaption}\item[{char \texorpdfstring{$\ast$}{*}}]{source,  }\item[{char \texorpdfstring{$\ast$}{*}}]{dest }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_ae8b8546b3350e1602c1574b1b0cb58d0}\label{sys__call_8c_ae8b8546b3350e1602c1574b1b0cb58d0} 
\index{sys\_call.c@{sys\_call.c}!s\_does\_file\_exist2@{s\_does\_file\_exist2}}
\index{s\_does\_file\_exist2@{s\_does\_file\_exist2}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_does\_file\_exist2()}{s\_does\_file\_exist2()}}
{\footnotesize\ttfamily off\+\_\+t s\+\_\+does\+\_\+file\+\_\+exist2 (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{fname }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a53c8865d5bf1ca946e5b5405190f6690}\label{sys__call_8c_a53c8865d5bf1ca946e5b5405190f6690} 
\index{sys\_call.c@{sys\_call.c}!s\_exit@{s\_exit}}
\index{s\_exit@{s\_exit}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_exit()}{s\_exit()}}
{\footnotesize\ttfamily void s\+\_\+exit (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Unconditionally exit the calling process. 

This will set the process state to zombied, adjust its state within the scheduler structures, and kill all child proceseses. (not done). \Hypertarget{sys__call_8c_a31e11484cfd56821c3e9a1fa43aafcf0}\label{sys__call_8c_a31e11484cfd56821c3e9a1fa43aafcf0} 
\index{sys\_call.c@{sys\_call.c}!s\_fg@{s\_fg}}
\index{s\_fg@{s\_fg}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_fg()}{s\_fg()}}
{\footnotesize\ttfamily int s\+\_\+fg (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpcb__t}{pcb\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{proc }\end{DoxyParamCaption})}

random number to convert int to string\Hypertarget{sys__call_8c_a35ff16131dec7dc8b25686329a19d0db}\label{sys__call_8c_a35ff16131dec7dc8b25686329a19d0db} 
\index{sys\_call.c@{sys\_call.c}!s\_find\_process@{s\_find\_process}}
\index{s\_find\_process@{s\_find\_process}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_find\_process()}{s\_find\_process()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structpcb__t}{pcb\+\_\+t}} \texorpdfstring{$\ast$}{*} s\+\_\+find\+\_\+process (\begin{DoxyParamCaption}\item[{pid\+\_\+t}]{pid }\end{DoxyParamCaption})}



Finds a process in any state. 


\begin{DoxyParams}{Parameters}
{\em pid} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pcb\+\_\+t\texorpdfstring{$\ast$}{*} 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_ab5efee98239591e685e3ae7da8203b21}\label{sys__call_8c_ab5efee98239591e685e3ae7da8203b21} 
\index{sys\_call.c@{sys\_call.c}!s\_function\_from\_string@{s\_function\_from\_string}}
\index{s\_function\_from\_string@{s\_function\_from\_string}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_function\_from\_string()}{s\_function\_from\_string()}}
{\footnotesize\ttfamily void \texorpdfstring{$\ast$}{*} s\+\_\+function\+\_\+from\+\_\+string (\begin{DoxyParamCaption}\item[{char \texorpdfstring{$\ast$}{*}}]{program }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a2638b24106c052e0a513643f712e8d00}\label{sys__call_8c_a2638b24106c052e0a513643f712e8d00} 
\index{sys\_call.c@{sys\_call.c}!s\_get\_fname\_from\_fd@{s\_get\_fname\_from\_fd}}
\index{s\_get\_fname\_from\_fd@{s\_get\_fname\_from\_fd}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_get\_fname\_from\_fd()}{s\_get\_fname\_from\_fd()}}
{\footnotesize\ttfamily char \texorpdfstring{$\ast$}{*} s\+\_\+get\+\_\+fname\+\_\+from\+\_\+fd (\begin{DoxyParamCaption}\item[{int}]{fd }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a18e6794b108eea25459bd7fe31de4e76}\label{sys__call_8c_a18e6794b108eea25459bd7fe31de4e76} 
\index{sys\_call.c@{sys\_call.c}!s\_kill@{s\_kill}}
\index{s\_kill@{s\_kill}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_kill()}{s\_kill()}}
{\footnotesize\ttfamily int s\+\_\+kill (\begin{DoxyParamCaption}\item[{pid\+\_\+t}]{pid,  }\item[{int}]{signal }\end{DoxyParamCaption})}



Send a signal to a particular process. 


\begin{DoxyParams}{Parameters}
{\em pid} & Process ID of the target proces. \\
\hline
{\em signal} & Signal number to be sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on error. 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_ae166ac7970869bda5550149e8771c3af}\label{sys__call_8c_ae166ac7970869bda5550149e8771c3af} 
\index{sys\_call.c@{sys\_call.c}!s\_ls@{s\_ls}}
\index{s\_ls@{s\_ls}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_ls()}{s\_ls()}}
{\footnotesize\ttfamily void s\+\_\+ls (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{filename,  }\item[{int}]{fd }\end{DoxyParamCaption})}



List the file filename in the current directory. If filename is NULL, list all files in the current directory. Before EC implementations, this should be very simple and could literally be a call a similar k\+\_\+function. 


\begin{DoxyParams}{Parameters}
{\em filename} & \\
\hline
\end{DoxyParams}
\Hypertarget{sys__call_8c_ac21f611f4fb486935d9ad2915a529d3b}\label{sys__call_8c_ac21f611f4fb486935d9ad2915a529d3b} 
\index{sys\_call.c@{sys\_call.c}!s\_lseek@{s\_lseek}}
\index{s\_lseek@{s\_lseek}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_lseek()}{s\_lseek()}}
{\footnotesize\ttfamily off\+\_\+t s\+\_\+lseek (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{int}]{offset,  }\item[{int}]{whence }\end{DoxyParamCaption})}



reposition the file pointer for fd to the offset relative to whence. You must also implement the constants F\+\_\+\+SEEK\+\_\+\+SET, F\+\_\+\+SEEK\+\_\+\+CUR, and F\+\_\+\+SEEK\+\_\+\+END, which reference similar file whences as their similarly named counterparts in lseek(2). A kernel level lseek should occur, and necessary changes to the calling process’ file descriptor table will be necessary. 


\begin{DoxyParams}{Parameters}
{\em fd} & \\
\hline
{\em offset} & \\
\hline
{\em whence} & \\
\hline
\end{DoxyParams}
\Hypertarget{sys__call_8c_a7cc95330d937650d14281e3d6041f284}\label{sys__call_8c_a7cc95330d937650d14281e3d6041f284} 
\index{sys\_call.c@{sys\_call.c}!s\_move\_process@{s\_move\_process}}
\index{s\_move\_process@{s\_move\_process}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_move\_process()}{s\_move\_process()}}
{\footnotesize\ttfamily int s\+\_\+move\+\_\+process (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structCircularList}{Circular\+List}} \texorpdfstring{$\ast$}{*}}]{destination,  }\item[{pid\+\_\+t}]{pid }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_ac711d33fcf2573a590b224b6debab996}\label{sys__call_8c_ac711d33fcf2573a590b224b6debab996} 
\index{sys\_call.c@{sys\_call.c}!s\_nice@{s\_nice}}
\index{s\_nice@{s\_nice}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_nice()}{s\_nice()}}
{\footnotesize\ttfamily int s\+\_\+nice (\begin{DoxyParamCaption}\item[{pid\+\_\+t}]{pid,  }\item[{int}]{priority }\end{DoxyParamCaption})}



Set the priority of the specified thread. 


\begin{DoxyParams}{Parameters}
{\em pid} & Process ID of the target thread. \\
\hline
{\em priority} & The new priorty value of the thread (0, 1, or 2) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure. 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_afec6e61720e05918efefeab347e950f3}\label{sys__call_8c_afec6e61720e05918efefeab347e950f3} 
\index{sys\_call.c@{sys\_call.c}!s\_open@{s\_open}}
\index{s\_open@{s\_open}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_open()}{s\_open()}}
{\footnotesize\ttfamily int s\+\_\+open (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{fname,  }\item[{int}]{mode }\end{DoxyParamCaption})}



open a file name fname with the mode mode and return a file descriptor. The allowed modes are as follows\+: 

F\+\_\+\+WRITE -\/ writing and reading, truncates if the file exists, or creates it if it does not exist. Only one instance of a file can be opened in F\+\_\+\+WRITE mode; error if Penn\+OS attempts to open a file in F\+\_\+\+WRITE mode more than once F\+\_\+\+READ -\/ open the file for reading only, return an error if the file does not exist F\+\_\+\+APPEND -\/ open the file for reading and writing but does not truncate the file if exists; additionally, the file pointer references the end of the file.

s\+\_\+open returns a file descriptor on success and a negative value on error. This open will initially be done at the kernel level, using a more intricate and already-\/implemented kernel level function. If the kernel level function succeeds and returns a fd, the user level function should also somehow keep track that such file descriptor is managed by the calling process. This can be done in multiple ways.


\begin{DoxyParams}{Parameters}
{\em fname} & \\
\hline
{\em mode} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_a4e0c2e47d0948979e7be9350582158c8}\label{sys__call_8c_a4e0c2e47d0948979e7be9350582158c8} 
\index{sys\_call.c@{sys\_call.c}!s\_print\_jobs@{s\_print\_jobs}}
\index{s\_print\_jobs@{s\_print\_jobs}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_print\_jobs()}{s\_print\_jobs()}}
{\footnotesize\ttfamily int s\+\_\+print\+\_\+jobs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structCircularList}{Circular\+List}} \texorpdfstring{$\ast$}{*}}]{list }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a2e87f593f5c2f59d7a90958b3e51751d}\label{sys__call_8c_a2e87f593f5c2f59d7a90958b3e51751d} 
\index{sys\_call.c@{sys\_call.c}!s\_print\_process@{s\_print\_process}}
\index{s\_print\_process@{s\_print\_process}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_print\_process()}{s\_print\_process()}}
{\footnotesize\ttfamily int s\+\_\+print\+\_\+process (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structCircularList}{Circular\+List}} \texorpdfstring{$\ast$}{*}}]{list }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_afdcf52e63af8002a5d7c02774ee0578f}\label{sys__call_8c_afdcf52e63af8002a5d7c02774ee0578f} 
\index{sys\_call.c@{sys\_call.c}!s\_read@{s\_read}}
\index{s\_read@{s\_read}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_read()}{s\_read()}}
{\footnotesize\ttfamily ssize\+\_\+t s\+\_\+read (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{int}]{n,  }\item[{char \texorpdfstring{$\ast$}{*}}]{buf }\end{DoxyParamCaption})}



read n bytes from the file referenced by fd. On return, s\+\_\+read returns the number of bytes read, 0 if EOF is reached, or a negative number on error. A kernel level read should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes. 


\begin{DoxyParams}{Parameters}
{\em fd} & \\
\hline
{\em n} & \\
\hline
{\em buf} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
ssize\+\_\+t 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_a18b25be5ab040f60070ff9ea839648be}\label{sys__call_8c_a18b25be5ab040f60070ff9ea839648be} 
\index{sys\_call.c@{sys\_call.c}!s\_read\_all@{s\_read\_all}}
\index{s\_read\_all@{s\_read\_all}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_read\_all()}{s\_read\_all()}}
{\footnotesize\ttfamily char \texorpdfstring{$\ast$}{*} s\+\_\+read\+\_\+all (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{filename,  }\item[{int \texorpdfstring{$\ast$}{*}}]{read\+\_\+num }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a964c6f7d6a06dddfd15cbd2d348dbd59}\label{sys__call_8c_a964c6f7d6a06dddfd15cbd2d348dbd59} 
\index{sys\_call.c@{sys\_call.c}!s\_reap\_all\_child@{s\_reap\_all\_child}}
\index{s\_reap\_all\_child@{s\_reap\_all\_child}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_reap\_all\_child()}{s\_reap\_all\_child()}}
{\footnotesize\ttfamily void s\+\_\+reap\+\_\+all\+\_\+child (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpcb__t}{pcb\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{parent }\end{DoxyParamCaption})}



Uses recursion to reap all children of specified parent. 


\begin{DoxyParams}{Parameters}
{\em parent} & PCB of the parent. \\
\hline
\end{DoxyParams}
\Hypertarget{sys__call_8c_a09ef4dc77a6071976f7d93759d48afa6}\label{sys__call_8c_a09ef4dc77a6071976f7d93759d48afa6} 
\index{sys\_call.c@{sys\_call.c}!s\_remove\_process@{s\_remove\_process}}
\index{s\_remove\_process@{s\_remove\_process}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_remove\_process()}{s\_remove\_process()}}
{\footnotesize\ttfamily int s\+\_\+remove\+\_\+process (\begin{DoxyParamCaption}\item[{pid\+\_\+t}]{pid }\end{DoxyParamCaption})}



Removes a process in any state. 


\begin{DoxyParams}{Parameters}
{\em pid} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_aeea2dcf94b9a35c86a67cf6ec97fd21d}\label{sys__call_8c_aeea2dcf94b9a35c86a67cf6ec97fd21d} 
\index{sys\_call.c@{sys\_call.c}!s\_rename@{s\_rename}}
\index{s\_rename@{s\_rename}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_rename()}{s\_rename()}}
{\footnotesize\ttfamily int s\+\_\+rename (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{source,  }\item[{const char \texorpdfstring{$\ast$}{*}}]{dest }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a0b8fdff50e5b9c5fa8559fe294e4243f}\label{sys__call_8c_a0b8fdff50e5b9c5fa8559fe294e4243f} 
\index{sys\_call.c@{sys\_call.c}!s\_sleep@{s\_sleep}}
\index{s\_sleep@{s\_sleep}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_sleep()}{s\_sleep()}}
{\footnotesize\ttfamily int s\+\_\+sleep (\begin{DoxyParamCaption}\item[{unsigned int}]{ticks }\end{DoxyParamCaption})}



Suspends execution of the calling proces for a specified number of clock ticks. 

This function is analogous to {\ttfamily sleep(3)} in Linux, with the behavior that the system clock continues to tick even if the call is interrupted. The sleep can be interrupted by a P\+\_\+\+SIGTERM signal, after which the function will return prematurely.


\begin{DoxyParams}{Parameters}
{\em ticks} & Duration of the sleep in system clock ticks. Must be greater than 0.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int Returns 0 on success, -\/1 on failure and sets errno. 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_a43b789c710ba1501bcd8cf54e4382e50}\label{sys__call_8c_a43b789c710ba1501bcd8cf54e4382e50} 
\index{sys\_call.c@{sys\_call.c}!s\_spawn@{s\_spawn}}
\index{s\_spawn@{s\_spawn}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_spawn()}{s\_spawn()}}
{\footnotesize\ttfamily pid\+\_\+t s\+\_\+spawn (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}(\texorpdfstring{$\ast$}{*})(void \texorpdfstring{$\ast$}{*})}]{func,  }\item[{char \texorpdfstring{$\ast$}{*}}]{argv\mbox{[}$\,$\mbox{]},  }\item[{int}]{fd0,  }\item[{int}]{fd1 }\end{DoxyParamCaption})}



Create a child process that executes the function {\ttfamily func}. The child will retain some attributes of the parent. 


\begin{DoxyParams}{Parameters}
{\em func} & Function to be executed by the child process. \\
\hline
{\em argv} & Null-\/terminated array of args, including the command name as argv\mbox{[}0\mbox{]}. \\
\hline
{\em fd0} & Input file descriptor. \\
\hline
{\em fd1} & Output file descriptor. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pid\+\_\+t The process ID of the created child process. // need to define error output? 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_a9116ac84aeec3a4717eab9aa7137080e}\label{sys__call_8c_a9116ac84aeec3a4717eab9aa7137080e} 
\index{sys\_call.c@{sys\_call.c}!s\_spawn\_and\_wait@{s\_spawn\_and\_wait}}
\index{s\_spawn\_and\_wait@{s\_spawn\_and\_wait}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_spawn\_and\_wait()}{s\_spawn\_and\_wait()}}
{\footnotesize\ttfamily int s\+\_\+spawn\+\_\+and\+\_\+wait (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}(\texorpdfstring{$\ast$}{*})(void \texorpdfstring{$\ast$}{*})}]{func,  }\item[{char \texorpdfstring{$\ast$}{*}}]{argv\mbox{[}$\,$\mbox{]},  }\item[{int}]{fd0,  }\item[{int}]{fd1,  }\item[{bool}]{nohang,  }\item[{unsigned int}]{priority }\end{DoxyParamCaption})}



Spawns and waits for a process. 

Spawns and waits for a process, combining s\+\_\+spawn and s\+\_\+waitpid.


\begin{DoxyParams}{Parameters}
{\em func} & \\
\hline
{\em argv} & \\
\hline
{\em fd0} & \\
\hline
{\em fd1} & \\
\hline
{\em nohang} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
or status signaled?\Hypertarget{sys__call_8c_a62b97025761b7f8ad7e59b641cad08d6}\label{sys__call_8c_a62b97025761b7f8ad7e59b641cad08d6} 
\index{sys\_call.c@{sys\_call.c}!s\_spawn\_nice@{s\_spawn\_nice}}
\index{s\_spawn\_nice@{s\_spawn\_nice}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_spawn\_nice()}{s\_spawn\_nice()}}
{\footnotesize\ttfamily pid\+\_\+t s\+\_\+spawn\+\_\+nice (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}(\texorpdfstring{$\ast$}{*})(void \texorpdfstring{$\ast$}{*})}]{func,  }\item[{char \texorpdfstring{$\ast$}{*}}]{argv\mbox{[}$\,$\mbox{]},  }\item[{int}]{fd0,  }\item[{int}]{fd1,  }\item[{unsigned int}]{priority }\end{DoxyParamCaption})}



Create a child process that executes the function {\ttfamily func}, with a specified priority. This is an exact copy of \doxylink{sys__call_8c_a43b789c710ba1501bcd8cf54e4382e50}{s\+\_\+spawn} except that the priority of the created process can be specificed at creation. 


\begin{DoxyParams}{Parameters}
{\em func} & Function to be executed by the child process. \\
\hline
{\em argv} & Null-\/terminated array of args, including the command name as argv\mbox{[}0\mbox{]}. \\
\hline
{\em fd0} & Input file descriptor. \\
\hline
{\em fd1} & Output file descriptor. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pid\+\_\+t The process ID of the created child process. 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_a395873f1de0b89a686d438580ba5dcf7}\label{sys__call_8c_a395873f1de0b89a686d438580ba5dcf7} 
\index{sys\_call.c@{sys\_call.c}!s\_unlink@{s\_unlink}}
\index{s\_unlink@{s\_unlink}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_unlink()}{s\_unlink()}}
{\footnotesize\ttfamily int s\+\_\+unlink (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{fname }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em fname} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_ab40c873ca412b774e2fc1b59527538be}\label{sys__call_8c_ab40c873ca412b774e2fc1b59527538be} 
\index{sys\_call.c@{sys\_call.c}!s\_update\_timestamp@{s\_update\_timestamp}}
\index{s\_update\_timestamp@{s\_update\_timestamp}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_update\_timestamp()}{s\_update\_timestamp()}}
{\footnotesize\ttfamily int s\+\_\+update\+\_\+timestamp (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{source }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_a3c0c6c4ae69799354d707ff57ac925d3}\label{sys__call_8c_a3c0c6c4ae69799354d707ff57ac925d3} 
\index{sys\_call.c@{sys\_call.c}!s\_waitpid@{s\_waitpid}}
\index{s\_waitpid@{s\_waitpid}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_waitpid()}{s\_waitpid()}}
{\footnotesize\ttfamily pid\+\_\+t s\+\_\+waitpid (\begin{DoxyParamCaption}\item[{pid\+\_\+t}]{pid,  }\item[{int \texorpdfstring{$\ast$}{*}}]{wstatus,  }\item[{bool}]{nohang }\end{DoxyParamCaption})}



Wait on a child of the calling process, until it changes state. If {\ttfamily nohang} is true, this will not block the calling process and return immediately. 


\begin{DoxyParams}{Parameters}
{\em pid} & Process ID of the child to wait for. \\
\hline
{\em wstatus} & Pointer to an integer variable where the status will be stored. \\
\hline
{\em nohang} & If true, return immediately if no child has exited. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pid\+\_\+t The process ID of the child which has changed state on success, -\/1 on error. 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_ad3317435b4bd7309160538fc5d730eb9}\label{sys__call_8c_ad3317435b4bd7309160538fc5d730eb9} 
\index{sys\_call.c@{sys\_call.c}!s\_write@{s\_write}}
\index{s\_write@{s\_write}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_write()}{s\_write()}}
{\footnotesize\ttfamily ssize\+\_\+t s\+\_\+write (\begin{DoxyParamCaption}\item[{int}]{fd,  }\item[{const char \texorpdfstring{$\ast$}{*}}]{str,  }\item[{int}]{n }\end{DoxyParamCaption})}



write n bytes of the string referenced by str to the file fd and increment the file pointer by n. On return, s\+\_\+write returns the number of bytes written, or a negative value on error. Note that this writes bytes not chars, these can be anything, even \textquotesingle{}\textbackslash{}0\textquotesingle{} A kernel level write should occur to perform the actual functionality, but its important to remember that the process’ file descriptor may need to be updated as the position of the file pointer changes. 


\begin{DoxyParams}{Parameters}
{\em fd} & \\
\hline
{\em str} & \\
\hline
{\em n} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
ssize\+\_\+t 
\end{DoxyReturn}
\Hypertarget{sys__call_8c_a1db57eb907f680ab844066357b793d5f}\label{sys__call_8c_a1db57eb907f680ab844066357b793d5f} 
\index{sys\_call.c@{sys\_call.c}!s\_write\_log@{s\_write\_log}}
\index{s\_write\_log@{s\_write\_log}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_write\_log()}{s\_write\_log()}}
{\footnotesize\ttfamily int s\+\_\+write\+\_\+log (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sys__call_8h_a9df1ce5034a7614c2c55bc05500f5991}{log\+\_\+message\+\_\+t}}}]{logtype,  }\item[{\mbox{\hyperlink{structpcb__t}{pcb\+\_\+t}} \texorpdfstring{$\ast$}{*}}]{proc,  }\item[{unsigned int}]{old\+\_\+nice }\end{DoxyParamCaption})}

\Hypertarget{sys__call_8c_abc68daae1d550a0993e99d583b0c1264}\label{sys__call_8c_abc68daae1d550a0993e99d583b0c1264} 
\index{sys\_call.c@{sys\_call.c}!s\_zombie@{s\_zombie}}
\index{s\_zombie@{s\_zombie}!sys\_call.c@{sys\_call.c}}
\doxysubsubsection{\texorpdfstring{s\_zombie()}{s\_zombie()}}
{\footnotesize\ttfamily void s\+\_\+zombie (\begin{DoxyParamCaption}\item[{pid\+\_\+t}]{pid }\end{DoxyParamCaption})}

